<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://diego3893.github.io</id>
    <title>Diego&apos;s Blog</title>
    <updated>2020-03-06T11:35:54.865Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://diego3893.github.io"/>
    <link rel="self" href="https://diego3893.github.io/atom.xml"/>
    <subtitle>Stay hungry, Stay foolish</subtitle>
    <logo>https://diego3893.github.io/images/avatar.png</logo>
    <icon>https://diego3893.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Diego&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Gridea静态博客使用CNAME以及相关配置]]></title>
        <id>https://diego3893.github.io/post/gridea-jing-tai-bo-ke-shi-yong-cname-yi-ji-xiang-guan-pei-zhi/</id>
        <link href="https://diego3893.github.io/post/gridea-jing-tai-bo-ke-shi-yong-cname-yi-ji-xiang-guan-pei-zhi/">
        </link>
        <updated>2020-03-05T00:14:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0-准备工作">0 准备工作</h1>
<p>注册域名使用<a href="https://cloud.tencent.com/">腾讯云</a><br>
加速以及https配置使用<a href="https://www.cloudflare.com/">cloudflare</a></p>
<hr>
<h1 id="1-注册域名">1 注册域名</h1>
<h2 id="11-注册">1.1 注册</h2>
<p>进入<a href="https://dnspod.cloud.tencent.com/">腾讯云</a>注册域名<br>
<s>购买过程不说，非常简单</s><br>
支付完成后，进入<a href="https://console.cloud.tencent.com/domain">管理页面</a></p>
<ul>
<li>如果<em>服务状态</em>显示未实名认证，请立即实名认证</li>
<li>认证完成后，<em>服务状态</em>会显示<strong>正常</strong></li>
<li></li>
<li>备案不管它</li>
</ul>
<h2 id="12-解析">1.2 解析</h2>
<p>进入<strong>解析</strong>页面<br>
<img src="https://s2.ax1x.com/2020/03/05/3Tawon.jpg" alt="CNAME" loading="lazy"><br>
添加两条解析记录，配置如图 <strong>（记录值为username.github.io，即博客地址）</strong></p>
<h2 id="13-cname绑定">1.3 CNAME绑定</h2>
<h3 id="131-github绑定">1.3.1 github绑定</h3>
<p>在<em>custom domain</em>中填入域名<br>
<img src="https://s2.ax1x.com/2020/03/05/3TdZYq.jpg" alt="N" loading="lazy"></p>
<h3 id="132-gridea绑定">1.3.2 Gridea绑定</h3>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2020/03/05/3TaHyD.jpg" alt="C" loading="lazy"></figure>
<hr>
<h1 id="2-在cloudflare中添加域名并启用cdn">2 在cloudflare中添加域名并启用CDN</h1>
<p>看这篇<a href="http://www.fangyuba.com/news/dynamic/197.htm">教程</a><br>
<strong>注</strong>：腾讯云修改DNS如下<br>
<img src="https://s2.ax1x.com/2020/03/05/3TUNU1.jpg" alt="DNS1" loading="lazy"><br>
<img src="https://s2.ax1x.com/2020/03/05/3TUtER.jpg" alt="DNS2" loading="lazy"></p>
<hr>
<h1 id="3-在cloudflare中配置https">3 在cloudflare中配置https</h1>
<h2 id="31-添加一条a记录">3.1 添加一条A记录</h2>
<p>在DNS目录下<br>
<img src="https://s2.ax1x.com/2020/03/05/3Tw02V.jpg" alt="settings" loading="lazy"><br>
确保是这两条（IPv4获取方式自行百度，cmd使用ping）</p>
<h2 id="32-打开https">3.2 打开https</h2>
<p>设置为Flexible<br>
<img src="https://s2.ax1x.com/2020/03/05/3Twbad.jpg" alt="F" loading="lazy"><br>
打开<em>always use https</em><br>
<img src="https://s2.ax1x.com/2020/03/05/3TwHVH.jpg" alt="U" loading="lazy"></p>
<h2 id="33-设置page-rules">3.3 设置Page Rules</h2>
<p><img src="https://s2.ax1x.com/2020/03/05/3T0ySP.jpg" alt="PR" loading="lazy"><br>
网址分别为<code>http://yourdomain/*</code>和<code>http://yourdomain/</code><br>
<img src="https://s2.ax1x.com/2020/03/05/3TBFmD.jpg" alt="P" loading="lazy"></p>
<hr>
<p>如果一切正常的话，应该会有以下：<br>
<img src="https://s2.ax1x.com/2020/03/05/3TDSEQ.jpg" alt="Active" loading="lazy"></p>
<p>有问题请在下方评论或发邮件询问我</p>
<blockquote>
<p>3013006997@qq.com</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图的存储]]></title>
        <id>https://diego3893.github.io/post/tu-de-cun-chu/</id>
        <link href="https://diego3893.github.io/post/tu-de-cun-chu/">
        </link>
        <updated>2020-03-01T13:33:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="邻接矩阵">邻接矩阵</h1>
<p><s>简单，不讲</s></p>
<blockquote>
<p><code>g[i][j]</code>表示从i到j的边权</p>
</blockquote>
<hr>
<h1 id="邻接表数组">邻接表（数组）</h1>
<blockquote>
<p>u, v, w记录边的信息<br>
first初始化-1，表示没有边<br>
first[u[i]]保存u[i]的第一条边编号，next[i]存储<em>编号为i的边</em>的下一条边的编号</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2020/03/01/32lNxe.jpg" alt="如图" loading="lazy"></figure>
<h2 id="模版">模版</h2>
<h3 id="无向图">无向图</h3>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#define N 100
using namespace std;
int main()
{
    int m;
    scanf(&quot;%d&quot;, &amp;m);
    int first[N*2], next[N*2];
    for(int i=0; i&lt;N; ++i)
    	first[i] = -1;
    int u[N*2], v[N*2], w[N*2];
    for(int i=1; i&lt;=m*2; i+=2)
    {
    	scanf(&quot;%d%d%d&quot;, &amp;u[i], &amp;v[i], &amp;w[i]);
    	u[i+1] = v[i];
    	v[i+1] = u[i];
    	w[i+1] = w[i];
    	next[i] = first[u[i]];
    	first[u[i]] = i;
    	next[i+1] = first[u[i+1]];
    	first[u[i+1]] = i+1;
	}
	int k;
	for(int i=1; i&lt;=m*2; ++i)
	{
		k = first[i];
		while(k != -1)
		{
			printf(&quot;%d %d %d\n&quot;, u[k], v[k], w[k]);
			k = next[k];
		}
	}	
    return 0;
}
</code></pre>
<h3 id="有向图">有向图</h3>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
int main()
{
    int m, n;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int first[n+1], next[m+1];
    for(int i=0; i&lt;N; ++i)
    	first[i] = -1;
    int u[m+1], v[m+1], w[m+1];
    for(int i=1; i&lt;=m; ++i)
    {
    	scanf(&quot;%d%d%d&quot;, &amp;u[i], &amp;v[i], &amp;w[i]);
    	next[i] = first[u[i]];
        first[u[i]] = i;
	}
	int k;
	for(int i=1; i&lt;=n; ++i)
	{
		k = first[i];
		while(k != -1)
		{
			printf(&quot;%d %d %d\n&quot;, u[k], v[k], w[k]);
			k = next[k];
		}
	}	
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最短路径]]></title>
        <id>https://diego3893.github.io/post/zui-duan-lu-jing/</id>
        <link href="https://diego3893.github.io/post/zui-duan-lu-jing/">
        </link>
        <updated>2020-03-01T12:47:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="floyd-warshall">Floyd-Warshall</h1>
<h2 id="原理">原理</h2>
<blockquote>
<p>分别枚举起始点i，中转点k，目标点j<br>
如果<code>e[i][k]+e[k][j] &lt; e[i][j]</code><br>
更新<code>e[i][j]</code>的值</p>
</blockquote>
<blockquote>
<p><mark>中转点</mark>枚举在最外层</p>
</blockquote>
<h2 id="模版">模版</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define N 100 
#define INF 0x7fffff
using namespace std;
int main()
{
	int g[N][N] = {};
	for(int i=0; i&lt;=N; ++i)
		for(int j=0; j&lt;=N; ++j)
			if(i != j)
				g[i][j] = INF;
			else
				g[i][j] = 0;
	int n, m;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	int u, v, w;
	for(int i=0; i&lt;m; ++i)
	{
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
		g[u][v] = w;
	}
	for(int k=1; k&lt;=n; ++k)
		for(int i=1; i&lt;=n; ++i)
			for(int j=1; j&lt;=n; ++j)
				g[i][j] = min(g[i][j], g[i][k]+g[k][j]);
	printf(&quot;%d&quot;, g[1][n]);
	return 0;
}
</code></pre>
<hr>
<h1 id="dijkstra">Dijkstra</h1>
<h2 id="原理-2">原理</h2>
<p>假设起点为1号节点</p>
<blockquote>
<p>初始化1号节点的出边权值至dis数组（估计值）<br>
找当前dis中最小边权（确定值）（假设为2号节点）<br>
以2号节点的出边边权更新dis数组，若<code>e[2][i]+dis[2] &lt; dis[i]</code>，就更新<code>dis[i]</code><br>
以此类推，进行<strong>松弛</strong></p>
</blockquote>
<blockquote>
<p>每次找离源点最近的点，然后依次进行扩展<br>
用book数组进行标记是否使用</p>
</blockquote>
<h2 id="模版-2">模版</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define N 100
#define INF 0x7ffff
using namespace std;
int main()
{
	int e[N][N], dis[N], book[N];
	int n, m;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i=1; i&lt;=n; ++i)
		for(int j=1; j&lt;=n; ++j)
			if(i == j)
				e[i][j] = 0;
			else
				e[i][j] = INF;
	int u, v, w;
	for(int i=1; i&lt;=m; ++i)
	{
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
		e[u][v] = w;
	}
	for(int i=1; i&lt;=n; ++i)
		dis[i] = e[1][i];
	memset(book, 0, sizeof(book));
	book[1] = 1;
	int minn = INF, k;
	for(int i=1; i&lt;=n; ++i)
	{
		minn = INF;
		for(int j=1; j&lt;=n; ++j)
			if(!book[j] &amp;&amp; dis[j]&lt;minn)
			{
				minn = dis[j];
				k = j;
			}
		book[k] = 1;
		for(int j=1; j&lt;=n; ++j)
			if(e[k][j]&lt;INF)
				dis[j] = min(dis[j], dis[k]+e[k][j]);
	}
	for(int i=1; i&lt;=n; ++i)
		printf(&quot;%d &quot;, dis[i]);
	return 0;
}

</code></pre>
<hr>
<h1 id="bellman-ford">Bellman-Ford</h1>
<h2 id="原理-3">原理</h2>
<blockquote>
<p>进行n-1轮松弛（详见Dijkstra）<br>
<s>没啥好说的</s></p>
</blockquote>
<h2 id="模版-3">模版</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define N 100
#define INF 0x7ffff
using namespace std;
int main()
{
	int dis[N], n, m, u[N], v[N], w[N];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i=1; i&lt;=m; ++i)
		scanf(&quot;%d%d%d&quot;, &amp;u[i], &amp;v[i], &amp;w[i]);
	for(int i=1; i&lt;=n; ++i)
		dis[i] = INF;
	dis[1] = 0;
	int check = 0;  //检查dis是否改变
	for(int i=1; i&lt;=n-1; ++i)
	{
		check = 0;
		for(int j=1; j&lt;=n; ++j)
			if(dis[v[j]] &gt; dis[u[j]]+w[j])
			{
				dis[v[j]] = dis[u[j]]+w[j];
				check = 1;
			}
		if(!check)  //优化
			break;
	}
	int flag = 0;
	for(int i=1; i&lt;=m; ++i)
		if(dis[v[i]] &gt; dis[u[i]]+w[i])
			flag = 1;
	if(flag)
		printf(&quot;有负权回路&quot;);
	else
		for(int i=1; i&lt;=n; ++i)
			printf(&quot;%d &quot;, dis[i]);
	return 0;
}
</code></pre>
<hr>
<h1 id="spfa">SPFA</h1>
<h2 id="原理-4">原理</h2>
<blockquote>
<p>用队列优化的Bellman-Ford<br>
思想差不多（Bellman-Ford+BFS）<br>
<em><strong>不用像BFS一样打标记（敲黑板）</strong></em></p>
</blockquote>
<p>不会邻接表的参考<a href="https://diego3893.github.io/post/tu-de-cun-chu/">我的这篇博文</a></p>
<h2 id="模版邻接表">模版（邻接表）</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define N 100
#define INF 0x7ffff

using namespace std;
int main()
{
	int n, m;
	int u[N], v[N], w[N];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	int first[n+1], next[m+1];
	int dis[N] = {}, book[N] = {}, que[N] = {}, head = 1, tail = 1;
	for(int i=1; i&lt;=n; ++i)
		dis[i] = INF;
	dis[1] = 0;
	for(int i=1; i&lt;=n; ++i)
		first[i] = -1;
	for(int i=1; i&lt;=m; ++i)
	{
		scanf(&quot;%d%d%d&quot;, &amp;u[i], &amp;v[i], &amp;w[i]);
		next[i] = first[u[i]];
		first[u[i]] = i;
	}
	que[tail++] = 1;
	book[1] = 1;
	int k;
	while(head &lt; tail)
	{
		k = first[que[head]];
		while(k != -1)
		{
			if(dis[v[k]] &gt; dis[u[k]]+w[k])
			{
				dis[v[k]] = dis[u[k]]+w[k];
				if(book[v[k]] == 0)
				{
					que[tail++] = v[k];
					book[v[k]] = 1;
				}
			}
			k = next[k];
		}
		book[que[head]] = 0;
		head++;
	}
	for(int i=1; i&lt;=n; ++i)
		printf(&quot;%d &quot;, dis[i]);
	return 0;
}

</code></pre>
<hr>
<h1 id="算法比较">算法比较</h1>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Floyd-Warshall</th>
<th style="text-align:center">Dijkstra</th>
<th style="text-align:center">Bellman-Ford</th>
<th style="text-align:center">SPFA</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">空间复杂度</td>
<td style="text-align:center">O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)</td>
<td style="text-align:center">O(M)</td>
<td style="text-align:center">O(M)</td>
<td style="text-align:center">O(M)</td>
</tr>
<tr>
<td style="text-align:center">时间复杂度</td>
<td style="text-align:center">O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">N^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)</td>
<td style="text-align:center">O((M+N)logN)</td>
<td style="text-align:center">O(NM)</td>
<td style="text-align:center">最坏也是O(NM)</td>
</tr>
<tr>
<td style="text-align:center">适用情况</td>
<td style="text-align:center">稠密图，与顶点关系密切</td>
<td style="text-align:center">稠密图，与顶点关系密切</td>
<td style="text-align:center">稀疏图，与边关系密切</td>
<td style="text-align:center">稀疏图，与边关系密切</td>
</tr>
<tr>
<td style="text-align:center">负权</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">负权边</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">负权回路判定</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL合集]]></title>
        <id>https://diego3893.github.io/post/stl-he-ji/</id>
        <link href="https://diego3893.github.io/post/stl-he-ji/">
        </link>
        <updated>2020-02-29T14:09:51.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2020/02/29/3618js.png" alt="1" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2020/02/29/361d4U.png" alt="2" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://s2.ax1x.com/2020/02/29/361YBq.png" alt="3" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://s2.ax1x.com/2020/02/29/361UEV.png" alt="4" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://s2.ax1x.com/2020/02/29/361aNT.png" alt="5" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://s2.ax1x.com/2020/02/29/361B34.png" alt="6" loading="lazy"></figure>
<p>也可以参考<a href="https://blog.csdn.net/shenaisi/article/details/81545418">这个</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++快读（数字）]]></title>
        <id>https://diego3893.github.io/post/ckuai-du-shu-zi/</id>
        <link href="https://diego3893.github.io/post/ckuai-du-shu-zi/">
        </link>
        <updated>2020-02-29T12:46:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="代码">代码</h1>
<pre><code class="language-cpp">inline int fread()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
</code></pre>
<hr>
<h1 id="原理">原理</h1>
<blockquote>
<p>getchar()比scanf()快</p>
<p>f判断正负</p>
</blockquote>
<blockquote>
<p>重点在<code>x = (x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48)</code><br>
<code>x&lt;&lt;1</code>= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>， <code>x&lt;&lt;3</code>= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mn>2</mn><mo>∗</mo><mn>2</mn><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x*2*2*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<blockquote>
<p><code>(x&lt;&lt;1)+(x&lt;&lt;3) = x*10</code></p>
</blockquote>
<p>ch^48=ch-'0'</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++版WIN XP ??!]]></title>
        <id>https://diego3893.github.io/post/cban-win-xp/</id>
        <link href="https://diego3893.github.io/post/cban-win-xp/">
        </link>
        <updated>2020-02-28T13:32:16.000Z</updated>
        <content type="html"><![CDATA[<p><code>转载自某位B站大神，如有侵权请联系邮箱：3013006997@qq.com</code></p>
<hr>
<h1 id="效果图">效果图：</h1>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2020/02/28/3rJk0P.jpg" alt="computer" loading="lazy"></figure>
<h1 id="原视频以及源码地址">原视频以及源码地址</h1>
<p><a href="https://www.bilibili.com/video/av88252843">video</a><br>
<a href="https://github.com/404name/winter/tree/master">source</a></p>
<h1 id="代码">代码</h1>
<pre><code class="language-cpp">/*--------------------------------------------------------- 
程序： 模拟笔记本电脑   （纯C语言，可直接编译器运行） 
作者： 0.0
说明： 1.这个程序本意在模拟电脑的基本功能，重在实现键盘的输入与键盘的控制，模拟开机，输密，打开软件，关闭电脑，所以其他功能暂没开发，不用太失望。 
	   2.不同的编码会有不同的长度显示，但运行出来的效果都是一样的 
	   3.代码规范不到位，见谅。 
	   4.大一上写的，一般写小游戏练手，也琢磨到一些特殊的处理方法，所以对一些功能处理上有一些难理解的地方。 
       5.emmm，没啥了
---------------------------------------------------------*/
#include &lt;conio.h&gt; //用于getch（）
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;windows.h&gt;
char start[20][300] = { //图形界面
    {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;},
    {&quot; \\                                                                                                                         /&quot;},
    {&quot;  \\                                                                                                                       /&quot;},
    {&quot;   \\                                                                                                                     /&quot;},
    {&quot;    \\                                                                                                                   /&quot;},
    {&quot;     \\                                                               /~/~/                                             /&quot;},
    {&quot;      \\                                                             /~/~/                                             /&quot;},
    {&quot;       \\                                     Microsotf@             ~ ~     __ XP                                    /&quot;},
    {&quot;        \\                                    \\  /\\  / -  _   _|  _  _   _  /_                                       /&quot;},
    {&quot;         \\                                    \\/  \\/  | | | |_| |_| \\/\\/  __/                                      /&quot;},
    {&quot;          \\                                                                                                       /&quot;},
    {&quot;           \\                                        _____________________                                        /&quot;},
    {&quot;            \\                                      │                    │                                       /&quot;},
    {&quot;             \\                                     └────────────────────┘                                      /&quot;},
    {&quot;              \\                                                                                               /&quot;},
    {&quot;               \\  Copyright ΘMicrosoft Corporation                                            Microsoft*    /&quot;},
    {&quot;                \\ __________________________________________________________________________________________/&quot;}};
char password[20][300] = {
    {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;},
    {&quot; \\                                                                                                                         /&quot;},
    {&quot;  \\  ------------------------------------------------------------------------------------------------------------------   /&quot;},
    {&quot;   \\                                                                                                                     /&quot;},
    {&quot;    \\                                                         |                                                         /&quot;},
    {&quot;     \\                                                        |                                                        /&quot;},
    {&quot;      \\                                                       |  ┌─────────────────────────────────────────────       /&quot;},
    {&quot;       \\                                           /~/~/      |  │┌─────┐  Administrator                             /&quot;},
    {&quot;        \\                                         /~/~/ __XP  |  ││ []│  输入密码                                 /&quot;},
    {&quot;         \\                \\  /\\  / -  _   _|  _   ~ ~  /_     |  │└─────┘  【|                 】ck[→]            /&quot;},
    {&quot;          \\                \\/  \\/  | | | |_| |_| \\/\\/ __/     |  └───────────────────────────────────────         /&quot;},
    {&quot;           \\                                                  |                                                  /&quot;},
    {&quot;            \\                  要开始，请单击您的用户名       |                                                 /&quot;},
    {&quot;             \\                                                |                                                /&quot;},
    {&quot;              \\                                                                                               /&quot;},
    {&quot;               \\   ----------------------------------------------------------------------------------------  /&quot;},
    {&quot;                \\ __________________________________________________________________________________________/&quot;}};
char desktop[20][300] = {
    {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;},
    {&quot; \\    ─────      ─────     ─────      ┌────┐    ┌────┐                                                                     /&quot;},
    {&quot;  \\   \\  [] \\    \\    \\    \\    \\     │    │    │ing │                                                                    /&quot;},
    {&quot;   \\    ─────     ─────     ─────     └────┘    └────┘                                                                   /&quot;},
    {&quot;    \\   小游戏     垃圾桶    计算器     相关     待开发                                                                 /&quot;},
    {&quot;     \\    ─────                                                                                                        /&quot;},
    {&quot;      \\   \\    \\                                                                                                      /&quot;},
    {&quot;       \\   ─────       __ --------------- __ __                                                                      /&quot;},
    {&quot;        \\  IE浏览器__--   --- __ -------_ -------_------____                                                        /&quot;},
    {&quot;         \\   ____     __--__ -- __ -------_ --- - __ --- __ --------------______                                   /&quot;},
    {&quot;          \\__  -------_--__  ------- __ ---------- __ ------ __ ------ __ --- __ ---------____                    /&quot;},
    {&quot;           \\  -------_---__  ------- _---- __ -------_ ---_ -------_ -_ ----------_ -_---_ -_ ------_ -_         /&quot;},
    {&quot;            \\--__ -- __ ----- __ ------ __ -------_ ---  ---- __ -------_ -_ ---------_ -_ ------_  -_ ------   /&quot;},
    {&quot;             \\ -_--__  ------- _---- __ -------_ ------- __ -------_ -- __ -------_ -_ --------__---_ -_ ------/&quot;},
    {&quot;              \\ _____________________________________________________________________________________________ /&quot;},
    {&quot;               \\ 开始 \\  qq2010   |                                                                 |  12:00 /&quot;},
    {&quot;                \\ __________________________________________________________________________________________/&quot;}};
char game_hnt[20][300] = {
    {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;},
    {&quot; \\   ┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐    /&quot;},
    {&quot;  \\                                                                                                                       /&quot;},
    {&quot;   \\                                                                                                                     /&quot;},
    {&quot;    \\                                                                                                                   /&quot;},
    {&quot;     \\                                                                                                                 /&quot;},
    {&quot;      \\                                                                                                               /&quot;},
    {&quot;       \\                                                                                                             /&quot;},
    {&quot;        \\                                                                                                           /&quot;},
    {&quot;         \\                                                                                                         /&quot;},
    {&quot;          \\                                                                                                       /&quot;},
    {&quot;           \\                                                                                                     /&quot;},
    {&quot;            \\                                                                                                   /&quot;},
    {&quot;             \\  └───────────────────────────────────────────────────────────────────────────────────────────┘  /&quot;},
    {&quot;              \\ _____________________________________________________________________________________________ /&quot;},
    {&quot;               \\ 开始 \\  qq2010   |  汉诺塔自动演示小游戏  |                                        |  12:08 /&quot;},
    {&quot;                \\ __________________________________________________________________________________________/&quot;}};
char thinking[30][300] = {
    {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;},
    {&quot; \\   ┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐    /&quot;},
    {&quot;  \\    这里是感想：                                                                                                       /&quot;},
    {&quot;   \\                                                                                                                     /&quot;},
    {&quot;    \\      寒假太颓废了，没劲学习，游戏玩腻，然后开始发呆。安静下来时才有灵感 ，看着笔记本，就想着我也编一个电脑系统吧  /&quot;},
    {&quot;     \\                                                                                                                 /&quot;},
    {&quot;      \\      就想把大一上学到的一些东西总着来练练手。。然后发现写电脑系统就是痴人说梦了，我还是写个模拟计算机吧。     /&quot;},
    {&quot;       \\                                                                                                             /&quot;},
    {&quot;        \\      对着自己笔记本的键盘一个一个的还原，然后思考如何体现屏幕，如何移动键盘，如何读取键盘把信息传给我的   /&quot;},
    {&quot;         \\                                                                                                         /&quot;},
    {&quot;          \\       虚拟电脑，如何模拟开机实现基本功能 ，一口气写完真心爽，最后想做互动游戏的，但这斜着的屏幕，emmm /&quot;},
    {&quot;           \\                                                                                                     /&quot;},
    {&quot;            \\       所以最后电脑只能运行汉诺塔，其他功能实现也简单，但还是把时间放在我突然又燃起的学习小火苗上吧/&quot;},
    {&quot;             \\  └───────────────────────────────────────────────────────────────────────────────────────────┘  /&quot;},
    {&quot;              \\ _____________________________________________________________________________________________ /&quot;},
    {&quot;               \\ 开始 \\  qq2010   |  感想.txt  |                                                   |  12:15 /&quot;},
    {&quot;                \\ __________________________________________________________________________________________/&quot;}};
char ending[30][300] = {
    {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;},
    {&quot; \\                                                                                                                         /&quot;},
    {&quot;  \\                                                      正在关机                                                         /&quot;},
    {&quot;   \\                                                                                                                     /&quot;},
    {&quot;    \\                                              请确保你的数据已保存                                                 /&quot;},
    {&quot;     \\                                                                                                                 /&quot;},
    {&quot;      \\                                                     0.0                                                       /&quot;},
    {&quot;       \\                                                                                                             /&quot;},
    {&quot;        \\                                               正在损失数据                                                /&quot;},
    {&quot;         \\                                                                                                         /&quot;},
    {&quot;          \\                                            电脑格式化成功                                             /&quot;},
    {&quot;           \\                                                                                                     /&quot;},
    {&quot;            \\                                           感谢使用  Xp                                            /&quot;},
    {&quot;             \\                                                                                                 /&quot;},
    {&quot;              \\                                                                                               /&quot;},
    {&quot;               \\                                                                                             /&quot;},
    {&quot;                \\ __________________________________________________________________________________________/&quot;}};
char map[10000][2000] = {
    {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;},
    {&quot; \\                                                                                                                         /&quot;},
    {&quot;  \\                                                                                                                       /&quot;},
    {&quot;   \\                                                                                                                     /&quot;},
    {&quot;    \\                                                                                                                   /&quot;},
    {&quot;     \\                                                                                                                 /&quot;},
    {&quot;      \\                                                                                                               /&quot;},
    {&quot;       \\                                                                                                             /&quot;},
    {&quot;        \\                                                                                                           /&quot;},
    {&quot;         \\                                                                                                         /&quot;},
    {&quot;          \\                                                                                                       /&quot;},
    {&quot;           \\                                                                                                     /&quot;},
    {&quot;            \\                                                                                                   /&quot;},
    {&quot;             \\                                                                                                 /&quot;},
    {&quot;              \\                                                                                               /&quot;},
    {&quot;               \\                                                                                             /&quot;},
    {&quot;                \\ __________________________________________________________________________________________/&quot;},
    {&quot;                ┌──────────────────────────────────────────────────────────────────────────────────────────┐&quot;},
    {&quot;                │                                                                                  ────    │&quot;},
    {&quot;                │──────────────────────────────────────────────────────────────────────────────────────────│&quot;},
    {&quot;                │┌─────┐  ┌───┬───┬───┬───┐┌───┬───┬───┬───┐┌───┬───┬───┬───┐┌───┬───┬───┐                 │&quot;},
    {&quot;                ││ Esc │  │ F1│ F2│ F3│ F4││ F5│ F6│ F7│ F8││ F9│F10│F11│F12││Prt│Scr│Pau│ ┌┐  ┌┐  ┌┐  ┌┐  │&quot;},
    {&quot;                │└─────┘  └───┴───┴───┴───┘└───┴───┴───┴───┘└───┴───┴───┴───┘└───┴───┴───┘ └┘  └┘  └┘  └┘  │&quot;},
    {&quot;                │┌────┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬─────┐┌───┬───┬───┐┌───┬───┬───┬───┐│&quot;},
    {&quot;                ││ `~ │ 1!│ 2@│ 3#│ 4$│ 5%│ 6^│ 7&amp;│ 8*│ 9(│ 0)│ -─│ =+│ ←--││Ins│Hom│Pgu││Num│ / │ * │ - ││&quot;},
    {&quot;                │├────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬────┤├───┼───┼───┤├───┼───┼───┼───┤│&quot;},
    {&quot;                ││ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │ [{│ ]}│ \\| ││Del│End│Pgd││ 7 │ 8 │ 9 │   ││&quot;},
    {&quot;                │├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴────┤└───┴───┴───┘├───┼───┼───┤ + ││&quot;},
    {&quot;                ││ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │ ;:│ \'\&quot;│ Enter │             │ 4 │ 5 │ 6 │   ││&quot;},
    {&quot;                │├──────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴───────┤    ┌───┐    ├───┼───┼───┼───┤│&quot;},
    {&quot;                ││ Shift │ Z │ X │ C │ V │ B │ N │ M │ ,&lt;│ .&gt;│ /?│   Shift  │    │ ↑│    │ 1 │ 2 │ 3 │  │││&quot;},
    {&quot;                │├────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴───┴──┬┴───╪───┬──────┤┌───┼───┼───┐├───┴───┼───┤  │││&quot;},
    {&quot;                ││ Ctr│ win│ Alt│            ────           │ Alt│ Fn│ Ctrl ││← │ ↓│ →││  0ins │.de│←┘││&quot;},
    {&quot;                │└────┴────┴────┴───────────────────────────┴────┴───┴──────┘└───┴───┴───┘└───────┴───┴───┘│&quot;},
    {&quot;                │               ┌───────────────────────────────┐                                          │&quot;},
    {&quot;                │               │                               │                                          │&quot;},
    {&quot;                │               │                               │                                          │&quot;},
    {&quot;                │               │───────────────┬───────────────│                                          │&quot;},
    {&quot;                │               └───────────────┴───────────────┘                                          │&quot;},
    {&quot;                └──────────────────────────────────────────────────────────────────────────────────────────┘&quot;}};
//功能数组
int keyboard[20][30] = {
    //把键盘看成一个地图让move函数在上面移动返回的数值对应下面的 board_place[120][5]是对应按键的全部信息
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 104, 104, 104, 104},
    {0, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37},
    {0, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58},
    {0, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 71, 0, 0, 0, 72, 73, 74, 58},
    {0, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 86, 86, 0, 87, 0, 88, 89, 90, 91},
    {0, 92, 93, 94, 95, 95, 95, 95, 95, 95, 95, 96, 97, 98, 98, 99, 100, 101, 102, 102, 103, 91},
};
int next[9][2] = {{0}, {0}, {0}, {0}, {0}, {-1, 0}, {0, -1}, {1, 0}, {0, 1}}; //给键盘传给虚拟键盘的键盘控制虚拟电脑用
int computer_map[3][8] = {{0, 0, 0, 0, 0}, {0, 1, 2, 3, 4}, {5, 0, 0, 0, 0}}; //对应的移动操作记录
int computer_map_place[6][2] = {{0}, {2, 9}, {2, 19}, {2, 29}, {2, 40}, {6, 12}};
int cx = 1, cy = 1, tcx = computer_map_place[computer_map[cx][cy]][0], tcy = computer_map_place[computer_map[cx][cy]][1], lcx = cx, lcy = cy;
int board_place[120][5] = { //这是按键的信息  下标依次对应  -返回值 -按下shift下的返回值2  -键盘字符长度  -字符坐标x   -y
    {0, 0, 0, 0, 0},        //第一项如果是字符那么那就是返回字符    如果是数字1-9那么就是功能按键功能对应如下
    {1, 1, 3, 21, 19},      //1-10
    {0, 0, 2, 21, 28},      //1 ~ 返回    2 ~删除     3确认   4shift  5上 6左 7下 8又  9开机
    {0, 0, 2, 21, 32},
    {0, 0, 2, 21, 36},
    {0, 0, 2, 21, 40},
    {0, 0, 2, 21, 45},
    {0, 0, 2, 21, 49},
    {0, 0, 2, 21, 53},
    {0, 0, 2, 21, 57},
    {0, 0, 2, 21, 62},
    {0, 0, 3, 21, 65}, // 11
    {0, 0, 3, 21, 69},
    {0, 0, 3, 21, 73},
    {0, 0, 3, 21, 78},
    {0, 0, 3, 21, 82},
    {0, 0, 3, 21, 86},
    {'`', '~', 2, 24, 19},
    {'1', '!', 2, 24, 24},
    {'2', '@', 2, 24, 28},
    {'3', '#', 2, 24, 32},
    {'4', '$', 2, 24, 36}, // 21
    {'5', '%', 2, 24, 40},
    {'6', '^', 2, 24, 44},
    {'7', '&amp;', 2, 24, 48},
    {'8', '*', 2, 24, 52},
    {'9', '(', 2, 24, 56},
    {'0', ')', 2, 24, 60},
    {'-', '_', 2, 24, 64},
    {'=', '+', 2, 24, 68},
    {2, 2, 4, 24, 72},
    {0, 0, 3, 24, 78}, // 31
    {0, 0, 3, 24, 82},
    {0, 0, 3, 24, 86},
    {0, 0, 3, 24, 91},
    {'/', '/', 1, 24, 96},
    {'*', '*', 1, 24, 100},
    {'-', '-', 1, 24, 104},
    {0, 0, 3, 26, 19},
    {'q', 'Q', 1, 26, 25},
    {'w', 'W', 1, 26, 29},
    {'e', 'E', 1, 26, 33}, // 41
    {'r', 'R', 1, 26, 37},
    {'t', 'T', 1, 26, 41},
    {'y', 'Y', 1, 26, 45},
    {'u', 'U', 1, 26, 49},
    {'i', 'I', 1, 26, 53},
    {'o', 'O', 1, 26, 57},
    {'p', 'P', 1, 26, 61},
    {'[', '{', 2, 26, 65},
    {']', '}', 2, 26, 69},
    {'\\', '|', 2, 26, 73}, // 51
    {0, 0, 3, 26, 78},
    {0, 0, 3, 26, 82},
    {0, 0, 3, 26, 86},
    {'7', '7', 1, 26, 92},
    {'8', '8', 1, 26, 96},
    {'9', '9', 1, 26, 100},
    {'+', '+', 1, 27, 104},
    {0, 0, 4, 28, 19},
    {'a', 'A', 1, 28, 26},
    {'s', 'S', 1, 28, 30}, // 61
    {'d', 'D', 1, 28, 34},
    {'f', 'F', 1, 28, 38},
    {'g', 'G', 1, 28, 42},
    {'h', 'H', 1, 28, 46},
    {'j', 'J', 1, 28, 50},
    {'k', 'K', 1, 28, 54},
    {'l', 'L', 1, 28, 58},
    {';', ':', 2, 28, 62},
    {'\'', '\&quot;', 2, 28, 66},
    {3, 3, 5, 28, 70}, // 71
    {'4', '4', 1, 28, 92},
    {'5', '5', 1, 28, 96},
    {'6', '6', 1, 28, 100},
    {4, 4, 5, 30, 19},
    {'z', 'Z', 1, 30, 27},
    {'x', 'X', 1, 30, 31},
    {'c', 'C', 1, 30, 35},
    {'v', 'V', 1, 30, 39},
    {'b', 'B', 1, 30, 43},
    {'n', 'N', 1, 30, 47}, // 81
    {'m', 'M', 1, 30, 51},
    {',', '&lt;', 2, 30, 55},
    {'.', '&gt;', 2, 30, 59},
    {'/', '?', 2, 30, 63},
    {4, 4, 5, 30, 69},
    {5, 5, 2, 30, 83},
    {'1', '1', 1, 30, 92},
    {'2', '2', 1, 30, 96},
    {'3', '3', 1, 30, 100},
    {3, 3, 3, 32, 103}, // 91
    {0, 0, 3, 32, 19},
    {0, 0, 3, 32, 24},
    {0, 0, 3, 32, 29},
    {' ', ' ', 4, 32, 45},
    {0, 0, 3, 32, 62},
    {0, 0, 2, 32, 67},
    {0, 0, 4, 32, 71},
    {6, 6, 2, 32, 78},
    {7, 7, 2, 32, 83},
    {8, 8, 2, 32, 87}, // 101
    {'0', '0', 4, 32, 93},
    {'.', '.', 4, 32, 99},
    {9, 9, 4, 18, 99}};

//  程序功能变量
int flag = 0, function, if_shift = 0, if_start = 0, if_input_password = 0, if_into_desktop = 0, if_game = 0; //0表示输入无效，1表示是输入电脑键 2表示是功能键，
char letter;
int x, y, tx, ty, num, lx, ly;
char temp[6] = {&quot;=====&quot;};
char put_in_computer[20];
char password_0[20] = {&quot;WHJY&quot;}; // 密码
int put_in_num = 0, if_input = 0, input_x, input_y, input_max;
//  汉诺塔游戏变量
int mid_x = 7, mid_y = 60;
int len, width, left, mid, right, time;
int ttx = 10, tty = 10;
char game_map[80][1000];
int game_next[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; //上0下1左2右3；

int turn[2][3] = {{0, 3, 1},  //a -&gt; b   b -&gt; c a -&gt; c  上右下
                  {0, 2, 1}}; //b -&gt; a  c -&gt; b  c -&gt; a	上左下     //实现自动移动的路线储存

void gotoxy(int x, int y) //坐标函数
{
    HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);
    COORD pos;
    pos.X = x;
    pos.Y = y;
    SetConsoleCursorPosition(handle, pos);
}
void init_game(int n)
{ //初始化汉诺塔
    time = 50 / n;
    left = 1, mid = 2 * (n + 1), right = mid + 2 * n + 1;
    len = 3 * (2 * n + 1);
    width = n + 1;
    ttx = mid_x - width / 2;
    tty = mid_y - len / 2;
    ;
    for (int i = 0; i &lt;= width; i++)
    {
        for (int j = 0, num = i; j &lt;= len; j++)
        {
            if (i == 0 || j == 0 || i == width || j == len)
                game_map[i][j] = '';
            if ((i &gt; 1 &amp;&amp; i &lt; width) &amp;&amp; (j == mid - 1 || j == right - 1))
                game_map[i][j] = '|';
            if (num &amp;&amp; (i &gt;= 1 &amp;&amp; i &lt;= width - 1) &amp;&amp; j % 2 != 0 &amp;&amp; j &lt; mid)
            {
                game_map[i][j] = -95;
                game_map[i][j + 1] = -10; //打印 ■  ■占2个字节可以拆开来
                num--;
            }
        }
    }
    //容易出现东西卡顿
    for (int i = 0; i &lt;= width; i++)
    {
        gotoxy(tty, ttx + i);
        for (int j = 0; j &lt;= len; j++)
            printf(&quot;%c&quot;, game_map[i][j]);
        printf(&quot;\n&quot;);
    }
}

void play(int x, int y)
{ //显示汉诺塔移动轨迹
    int turn_0, n = 0, i, j, k, tx, ty, flag = 0;
    if ((x == mid &amp;&amp; y == right) || (x == left &amp;&amp; y == mid) || (x == left &amp;&amp; y == right))
        turn_0 = 0; //往右
    else if ((x == mid &amp;&amp; y == left) || (x == right &amp;&amp; y == left) || (x == right &amp;&amp; y == mid))
        turn_0 = 1; //往左
    for (i = 1, j = y; i &lt;= width; i++)
    { //目的地
        if (game_map[i][j] != 0)
        {
            tx = i - 1;
            ty = j;
            break;
        }
    }
    for (i = 1, j = x; i &lt;= width; i++)
    { //出发点
        if (game_map[i][j] != 0)
        {
            break;
        }
    }
    while (1)
    {
        while ((i != 1 || j != x) &amp;&amp; (i != 1 || j != y) &amp;&amp; (i != tx || j != ty))
        {
            if (turn_0 == 0)
                for (k = mid - 3; k &gt;= 0; k--)
                {
                    game_map[i + game_next[turn[turn_0][n]][0]][j + game_next[turn[turn_0][n]][1] + k] = game_map[i][j + k];
                    game_map[i][j + k] = 0;
                }
            else
                for (k = 0; k &lt; mid - 2; k++)
                {
                    game_map[i + game_next[turn[turn_0][n]][0]][j + game_next[turn[turn_0][n]][1] + k] = game_map[i][j + k];
                    game_map[i][j + k] = 0;
                }
            gotoxy(j + tty, i + ttx);
            Sleep(time);
            for (k = 0; k &lt; mid - 2; k++)
            {
                printf(&quot; &quot;);
            }
            i = i + game_next[turn[turn_0][n]][0];
            j = j + game_next[turn[turn_0][n]][1];
            gotoxy(j + tty, i + ttx);
            Sleep(time);
            for (k = 0; k &lt; mid - 2; k++)
            {
                printf(&quot;%c&quot;, game_map[i][j + k]);
            }
        }
        n++; //改变方向;
        if (i == tx &amp;&amp; j == ty)
            return;
        if (turn_0 == 0)
            for (k = mid - 3; k &gt;= 0; k--)
            {
                game_map[i + game_next[turn[turn_0][n]][0]][j + game_next[turn[turn_0][n]][1] + k] = game_map[i][j + k];
                game_map[i][j + k] = 0;
            }
        else
            for (k = 0; k &lt; mid - 2; k++)
            {
                game_map[i + game_next[turn[turn_0][n]][0]][j + game_next[turn[turn_0][n]][1] + k] = game_map[i][j + k];
                game_map[i][j + k] = 0;
            }
        gotoxy(j + tty, i + ttx);
        for (k = 0; k &lt; mid - 2; k++)
        {
            printf(&quot; &quot;);
        }
        Sleep(time);
        i = i + game_next[turn[turn_0][n]][0];
        j = j + game_next[turn[turn_0][n]][1];
        gotoxy(j + tty, i + ttx);
        for (k = 0; k &lt; mid - 2; k++)
            printf(&quot;%c&quot;, game_map[i][j + k]);
        Sleep(time);
    }
}

void move_hnt(int a, int b, int c, char aa, char bb, char cc, int n)
{ //正常的汉诺塔递归程序
    if (n == 1)
    {
        //printf(&quot;from %c to %c&quot;,aa,cc);
        play(a, c);
        return;
    }
    move_hnt(a, c, b, aa, cc, bb, n - 1);
    /*	gotoxy(0,width+1);
	printf(&quot;from %c to %c&quot;,aa,cc);*/
    play(a, c);
    move_hnt(b, a, c, bb, aa, cc, n - 1);
}
void init()
{ //初始化整个程序
    printf(&quot;↑ ↓ ← → 空格    进行操作\n\n&quot;);
    printf(&quot;用空格按下电源键即可进行开机\n\n&quot;);
    printf(&quot;xp系统祝你使用愉快~~\n\n&quot;);
    printf(&quot;开机密码WHJY\n&quot;);
    printf(&quot;桌面程序只有第一个和相关有用，其他暂未开放\n&quot;);
    printf(&quot;汉诺塔程序运行过程中是不能中止的，尽量开6个以下\n&quot;); //这里是原本写了一个版本，自动变化函数+人工输入函数能中途退出，但改一下整个程序都要改动，就放弃了那个版本
    printf(&quot;按任意键继续\n&quot;);
    getch();
    int i, j, k;
    system(&quot;color 70&quot;);
    system(&quot;mode con cols=125 lines=60&quot;);
    for (int i = 0; i &lt;= 40; i++)
    {
        printf(&quot;%s\n&quot;, map[i]);
        Sleep(50);
    }
    x = 1, y = 20, num = board_place[keyboard[x][y]][2];
    tx = board_place[keyboard[x][y]][3];
    ty = board_place[keyboard[x][y]][4];
    gotoxy(ty, tx);
    //SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),02);
    for (i = 0; i &lt; num; i++)
    {
        printf(&quot;%c&quot;, temp[i]);
    }
}
void init_start()
{ // 开机 + 动态加载页面 + 打开输入密码权限
    gotoxy(0, 0);
    for (int i = 0; i &lt;= 16; i++)
    {
        printf(&quot;%s\n&quot;, start[i]);
        Sleep(100);
    }
    int l, i, j;
    for (l = 0; l &lt; 3; l++)
    { //动态加载
        for (i = 53; i &lt;= 71; i = i + 2)
        {
            for (j = i - 4; j &lt;= i; j = j + 2)
            {
                if (j &gt;= 53 &amp;&amp; j &lt;= 70)
                {
                    gotoxy(j, 12);
                    printf(&quot;[]&quot;);
                }
                Sleep(100);
            }
            for (j = i - 4; j &lt;= i; j = j + 2)
            {
                if (j &gt;= 53 &amp;&amp; j &lt;= 70)
                {
                    gotoxy(j, 12);
                    printf(&quot;  &quot;);
                }
            }
        }
    }
    gotoxy(0, 0);
    for (int i = 0; i &lt;= 16; i++)
    {
        printf(&quot;%s\n&quot;, password[i]);
        Sleep(10);
    }
    if_input = 1; //  9 77    18个
    input_x = 9;
    input_y = 77;
    input_max = 18;
}
void load_desktop()
{ //加载桌面
    if_into_desktop = 1;
    if_input == 0;
    gotoxy(0, 0);
    for (int i = 0; i &lt;= 16; i++)
    {
        printf(&quot;%s\n&quot;, desktop[i]);
        Sleep(100);
    }
}
void end()
{ //加载关机 （关机做的有点仓促）
    gotoxy(0, 0);
    for (int i = 0; i &lt;= 16; i++)
    {
        printf(&quot;%s\n&quot;, ending[i]);
        Sleep(1000);
    }
    gotoxy(0, 0);
    for (int i = 0; i &lt;= 16; i++)
    {
        printf(&quot;%s\n&quot;, map[i]);
        Sleep(10);
    }
}
void load_more()
{ //更多信息
    gotoxy(0, 0);
    for (int i = 0; i &lt;= 16; i++)
    {
        printf(&quot;%s\n&quot;, thinking[i]);
        Sleep(1000);
    }
}
void load_game()
{ //加载汉诺塔程序
    if_into_desktop = 0;
    gotoxy(0, 0);
    for (int i = 0; i &lt;= 16; i++)
    {
        printf(&quot;%s\n&quot;, game_hnt[i]);
        Sleep(100);
    }
    if_game = 1;
    gotoxy(mid_y - 16, mid_x);
    printf(&quot;请输入你要递归的汉诺塔数目_&quot;);
    input_x = mid_x;
    input_y = mid_y - 16 + 27;
    input_max = 1;
    if_input = 1;
}
int move()
{ //控制虚拟键盘的指针移动函数
    int i, k;
    char ch = '\0', ch1 = '\0';
    while (ch != ' ')
    {
        ch = getch();
        lx = x, ly = y;
        if (ch != ' ' &amp;&amp; ch != 'w' &amp;&amp; ch != 's' &amp;&amp; ch != 'a' &amp;&amp; ch != 'd' &amp;&amp;
            ch != -32)
            continue;
        if (ch == -32)
        { //同时启用wasd  和上下左右键   //如果读取到第一个是-32那么 继续读取一个字符
            ch1 = getch();
            switch (ch1)
            {
            case 72:
                ch = 'w';
                break;
            case 75:
                ch = 'a';
                break;
            case 80:
                ch = 's';
                break;
            case 77:
                ch = 'd';
                break;
            }
        }
        system(&quot;color 70&quot;);
        gotoxy(0, tx);
        printf(&quot;%s&quot;, map[tx]);
        switch (ch)
        {
        case 'a':
            y = y - 1;
            break;
        case 'd':
            y = y + 1;
            break;
        case 'w':
            x = x - 1;
            break;
        case 's':
            x = x + 1;
            break;
        case ' ':
            break;
        }
        if (keyboard[x][y] == 0)
        {
            x = lx;
            y = ly;
        }
        num = board_place[keyboard[x][y]][2];
        tx = board_place[keyboard[x][y]][3];
        ty = board_place[keyboard[x][y]][4];
        gotoxy(ty, tx);
        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 57);
        for (i = 0; i &lt; num; i++)
        {
            printf(&quot;%c&quot;, temp[i]);
        }
        gotoxy(ty, tx);
    }
    system(&quot;color 70&quot;);
    if (board_place[keyboard[x][y]][0] == 0)
        return 0;
    else if (board_place[keyboard[x][y]][0] &gt;= 1 &amp;&amp; board_place[keyboard[x][y]][0] &lt;= 9)
    {
        function = board_place[keyboard[x][y]][0];
        /*gotoxy(0,41);
    	printf(&quot;%d&quot;,board_place[ keyboard[x][y] ][0]);*/
        return 2;
    }
    else
    {
        letter = if_shift ? board_place[keyboard[x][y]][1] : board_place[keyboard[x][y]][0];
        /*gotoxy(0,41);
    	printf(&quot;%c&quot;,board_place[ keyboard[x][y] ][0]);*/
        return 1;
    }
}
void put_letter_to_computer(char letter)
{ //把字符传输给电脑屏幕，如果电脑if_input为零就禁止显示
    if (if_input == 1 &amp;&amp; put_in_num &lt; input_max)
    {
        put_in_computer[put_in_num] = letter;
        put_in_num++;
        put_in_computer[put_in_num] = '\0';
    }
    gotoxy(input_y, input_x);
    printf(&quot;%s&quot;, put_in_computer);
}
void put_function_to_computer(int function)
{ //电脑处理相应共呢   1 ~ 返回    2 ~删除     3确认   4shift  5上 6左 7下 8又  9开机
    if (function == 9)
    { //开机
        if (if_start == 0)
        {
            init_start();
            if_start = 1;
        }
        else
        {
            end();
            if_start = 0;
            if_into_desktop = 0;
        }
    }
    if (function == 2 &amp;&amp; put_in_num &gt; 0 &amp;&amp; if_input == 1)
    { //删除字符，但不可越界
        put_in_num--;
        put_in_computer[put_in_num] = '\0';
        gotoxy(input_y, input_x);
        printf(&quot;%s&quot;, put_in_computer);
        printf(&quot; &quot;);
    }
    if (function == 4)
    { //切换大小写
        if (if_shift)
            if_shift = 0;
        else
            if_shift = 1;
    }
    if (function == 3 &amp;&amp; if_input == 1 &amp;&amp; if_game == 0)
    { //确认对应不同模式下的不同功能
        if (strcmp(password_0, put_in_computer) == 0)
        {
            load_desktop();
            if_input = 0;
            put_in_num = 0;
            put_in_computer[put_in_num] = '\0';
        }
        else
        {
            put_in_num = 0;
            put_in_computer[put_in_num] = '\0';
            gotoxy(input_y, input_x);
            printf(&quot;密 码 错 误 ！！！&quot;);
            gotoxy(input_y, input_x);
            Sleep(1200);
            printf(&quot;                  &quot;);
            gotoxy(input_y, input_x);
            printf(&quot;|&quot;);
        }
    }
    else if (function == 3 &amp;&amp; if_game == 1 &amp;&amp; put_in_num == 1 &amp;&amp; put_in_computer[0] &gt;= '1' &amp;&amp; put_in_computer[0] &lt;= '9')
    {
        gotoxy(mid_y - 16, mid_x);
        printf(&quot;                                               &quot;);
        init_game(put_in_computer[0] - '0');
        move_hnt(left, mid, right, 'a', 'b', 'c', put_in_computer[0] - '0');
        Sleep(2000);
        for (int i = 0; i &lt;= width; i++)
        {
            for (int j = 0; j &lt;= len; j++)
            {
                game_map[i][j] = 0;
            }
        }
        if_game == 0;
        if_input = 0;
        load_desktop();
        if_into_desktop = 1;
        put_in_num = 0;
        put_in_computer[0] = '\0';
    }
    else if (function == 3 &amp;&amp; if_into_desktop)
    {
        if (cy == 1)
        {
            load_game();
            if_game = 1;
        }
        else
        {
            load_more();
            getch();
            load_desktop();
        }
    }
    //if(if_game == 1 &amp;&amp; function &gt;= 5 &amp;&amp; function &lt;= 8))     移动类型游戏暂未开放
    if (if_into_desktop &amp;&amp; function &gt;= 5 &amp;&amp; function &lt;= 8)
    {
        int ncx = cx + next[function][0], ncy = cy + next[function][1];
        if (computer_map[ncx][ncy])
        {
            gotoxy(tcy, tcx);
            printf(&quot;  &quot;);
            cx = ncx, cy = ncy;
            tcx = computer_map_place[computer_map[cx][cy]][0];
            tcy = computer_map_place[computer_map[cx][cy]][1];
            lcx = cx, lcy = cy;
            gotoxy(tcy, tcx);
            printf(&quot;[]&quot;);
        }
    }
    if (function == 1 &amp;&amp; if_into_desktop)
    { //返回
        load_desktop();
    }
}

int main()
{
    init();
    /*load_desktop();//直接进入桌面
	if_start = 1; 
	if_into_desktop = 1;*/
    while (1)
    {                  //主循环
        flag = move(); //move提取读取的键盘按键并判断类型
        switch (flag)
        {
        case 0:
            break; //暂无效果的按键
        case 1:
            put_letter_to_computer(letter);
            break; //返回字符型按键给电脑
        case 2:
            put_function_to_computer(function);
            break; //返回功能型按键给电脑
        }
    }
    getchar();
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快速幂]]></title>
        <id>https://diego3893.github.io/post/kuai-su-mi/</id>
        <link href="https://diego3893.github.io/post/kuai-su-mi/">
        </link>
        <updated>2020-02-28T13:06:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="原理">原理</h1>
<blockquote>
<p>在指数b大于0时：</p>
<blockquote>
<p>若b为奇数，先将ans单独乘以底数a并mod m， 再将底数平方并mod m<br>
若b为偶数，将底数平方并mod m</p>
</blockquote>
<p>b右移一位，即b/2<br>
时间复杂度：O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span></span></span></span>)<br>
数学理解很简单，位运算参考<a href="https://jingyan.baidu.com/article/1612d5008ff5b7e20f1eee4c.html">这个</a></p>
</blockquote>
<h1 id="模版">模版</h1>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
typedef long long ll;
ll qpower(ll, ll, ll);
int main()
{
	ll a, b, m;
	scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;m);
	printf(&quot;%lld&quot;, qpower(a, b, m));
 } 
ll qpower(ll a, ll b, ll m)
{
	ll ans = 1, res = a;
	while(b &gt; 0)
	{
		if(b &amp; 1)
			ans = ans*res%m;
		res = res*res%m;
		b &gt;&gt;= 1;
	}
	return ans;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找]]></title>
        <id>https://diego3893.github.io/post/er-fen-cha-zhao/</id>
        <link href="https://diego3893.github.io/post/er-fen-cha-zhao/">
        </link>
        <updated>2020-02-28T12:19:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="原理">原理</h1>
<p>简单，不阐述</p>
<hr>
<h1 id="模版">模版</h1>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2020/02/28/3rmptI.jpg" alt="code" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[堆排序]]></title>
        <id>https://diego3893.github.io/post/dui-pai-xu/</id>
        <link href="https://diego3893.github.io/post/dui-pai-xu/">
        </link>
        <updated>2020-02-28T11:14:25.000Z</updated>
        <content type="html"><![CDATA[<p>堆分为<mark>大根堆</mark>，<mark>小根堆</mark><br>
本文以<strong>大根堆</strong>为例</p>
<hr>
<h1 id="原理">原理</h1>
<blockquote>
<p>一个数组存储整个序列</p>
<blockquote>
<p>下标为k的数左孩子为2k+1, 右孩子为2k+2</p>
</blockquote>
<p>保持每个子树的根值大于它孩子的值</p>
<p>对每一个非叶子节点进行排序<br>
将整棵树的根节点（序列最大值）放到正在进行排序的末尾i<br>
对0~i-1的序列继续排序<br>
<code>数组模拟的完全二叉树</code></p>
</blockquote>
<hr>
<h1 id="模版">模版</h1>
<h2 id="手动模拟">手动模拟</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

void adjust(int arr[], int len, int index)
{
    int left = 2*index + 1;
    int right = 2*index + 2;
    int maxIdx = index;
    if(left&lt;len &amp;&amp; arr[left] &gt; arr[maxIdx]) maxIdx = left;
    if(right&lt;len &amp;&amp; arr[right] &gt; arr[maxIdx]) maxIdx = right;  // maxIdx是3个数中最大数的下标
    if(maxIdx != index)                 // 如果maxIdx的值有更新
    {
        swap(arr[maxIdx], arr[index]);
        adjust(arr, len, maxIdx);       // 递归调整其他不满足堆性质的部分
    }

}
void heapSort(int arr[], int size)
{
    for(int i=size/2 - 1; i &gt;= 0; i--)  // 对每一个非叶结点进行堆调整(从最后一个非叶结点开始)
    {
        adjust(arr, size, i);
    }
    for(int i = size - 1; i &gt;= 1; i--)
    {
        swap(arr[0], arr[i]);           // 将当前最大的放置到数组末尾
        adjust(arr, i, 0);              // 将未完成排序的部分继续进行堆排序
    }
}

int main()
{
    int array[8] = {8, 1, 14, 3, 21, 5, 7, 10};
    heapSort(array, 8);
    for(int i=0; i&lt;8; ++i)
    	cout&lt;&lt;array[i]&lt;&lt;' ';
    return 0;
}
</code></pre>
<h2 id="stl">STL</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
int n,x,ans;
priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q;
int main()
{
	int n, x, ans = 0;
    scanf(&quot;%d&quot;, &amp;n); 
    for(int i=1;i&lt;=n;i++) 
	{
		scanf(&quot;%d&quot;, &amp;x);
		q.push(x);
	}
    while(q.size()&gt;=2)
	{
        int a=q.top(); 
		q.pop();
        int b=q.top(); 
		q.pop();
        ans += a+b;
        q.push(a+b);
    }
    printf(&quot;%d&quot;, ans);
    return 0;
}
</code></pre>
<p>代码题目<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1369">传送门</a></p>
<h3 id="注意">注意</h3>
<ul>
<li>不使用<code>#include&lt;vector&gt;</code>头文件</li>
<li>greater是序列升序，less是序列降序</li>
<li>声明语句最后的两个 <mark>&gt; &gt;</mark> 要有一个<strong>空格</strong></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[github + Gridea免费搭建静态博客]]></title>
        <id>https://diego3893.github.io/post/github-gridea-mian-fei-da-jian-jing-tai-bo-ke/</id>
        <link href="https://diego3893.github.io/post/github-gridea-mian-fei-da-jian-jing-tai-bo-ke/">
        </link>
        <updated>2020-02-28T01:39:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0-gridea的优缺点">0 Gridea的优缺点</h1>
<p><strong>优点</strong>：</p>
<ul>
<li>使用简单</li>
<li>零成本</li>
<li>无需代码配置</li>
<li>界面美观</li>
<li>离线编辑，在线同步</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>
<p>新软件没有详细说明 <s>（所以需要看我的博客）</s></p>
<hr>
<h1 id="1-准备工作">1 准备工作</h1>
<h2 id="安装git可选和gridea">安装git（可选）和Gridea</h2>
</li>
</ul>
<ul>
<li>
<p>可以从官网安装：</p>
<blockquote>
<p><a href="https://git-scm.com/downloads" title="git下载地址">git</a></p>
</blockquote>
<blockquote>
<p><a href="https://gridea.dev" title="gridea下载地址">Gridea</a></p>
</blockquote>
</li>
<li>
<p>可以从百度网盘安装</p>
<blockquote>
<p><a href="https://pan.baidu.com/s/1nTCfBIsZqMGD8tokXiEdYQ" title="网盘资源">网盘资源</a><br>
<mark>提取码：ck6t</mark></p>
<blockquote>
<p>有git、gridea安装包和gridea主题  <em><strong>（仅限win）</strong></em></p>
</blockquote>
</blockquote>
</li>
</ul>
<hr>
<h1 id="2-安装软件">2 安装软件</h1>
<h2 id="21-安装git可选">2.1 安装git（可选）</h2>
<p>参考<a href="https://blog.csdn.net/qq_32786873/article/details/80570783" title="git安装教程">这个</a></p>
<h2 id="22-安装gridea">2.2 安装Gridea</h2>
<p>双击exe，选择全用户安装（第一个选项），然后一路<em>下一步</em>即可</p>
<hr>
<h1 id="3-搭建网站">3 搭建网站</h1>
<h2 id="30-加速github">3.0 加速github</h2>
<p>参考<a href="https://blog.csdn.net/qianglei6077/article/details/90051554" title="win10加速">这个</a><br>
<em>无法保存hosts</em><a href="https://jingyan.baidu.com/article/9113f81b49ed2f2b3214c7fa.html%22%E6%B7%BB%E5%8A%A0%E6%9D%83%E9%99%90%22">解决办法</a></p>
<h2 id="31注册github有账号者略过">3.1注册github（有账号者略过）</h2>
<p>进入<a href="https://github.com">github</a><br>
具体步骤和其他注册方式无太大区别，此处不再赘述</p>
<h2 id="32-创建仓库">3.2 创建仓库</h2>
<p>点击<strong>New repository</strong><br>
<img src="https://s2.ax1x.com/2020/02/28/3BGwZT.jpg" alt="creat" loading="lazy"><br>
<mark>Repository name</mark>填写<em>用户名.github.io</em><br>
<code>e.g. 用户名为kkk， 则Repository name填写kkk.github.io</code><br>
Description可以<strong>不填</strong><br>
其余设置参照下图，然后点击<em>Create repository</em><br>
<img src="https://s2.ax1x.com/2020/02/28/3BJo7T.jpg" alt="creat0" loading="lazy"></p>
<h2 id="33-获取token">3.3 获取token</h2>
<ul>
<li>进入用户设置<br>
<img src="https://s2.ax1x.com/2020/02/28/3BNR9e.jpg" alt="token0" loading="lazy"></li>
<li>进入开发者设置<br>
<img src="https://s2.ax1x.com/2020/02/28/3BUk34.jpg" alt="token1" loading="lazy"></li>
<li>选择最后一项，然后新建一个token<br>
<img src="https://s2.ax1x.com/2020/02/28/3BU524.jpg" alt="token2" loading="lazy"></li>
<li>Note随便填，只勾选repo权限<br>
<img src="https://s2.ax1x.com/2020/02/28/3BaiZt.jpg" alt="token3" loading="lazy"></li>
<li>点击页面最下方的绿色按钮<em>Generate token</em></li>
<li>你会得到一长串编码，<mark>把它保存下来</mark>，因为 <em><strong>以后你再也见不到它了</strong></em><br>
<img src="https://s2.ax1x.com/2020/02/28/3BdNh8.jpg" alt="token4" loading="lazy"></li>
</ul>
<hr>
<h1 id="4-gridea设置博客">4 gridea设置博客</h1>
<h2 id="41-将博客同步至网页">4.1 将博客同步至网页</h2>
<p>在<strong>远程</strong>中设置如图<br>
<img src="https://s2.ax1x.com/2020/02/28/3B0q6e.jpg" alt="setting" loading="lazy"><br>
点击<strong>保存</strong>，点击<strong>检测远程连接</strong></p>
<blockquote>
<p>如果失败请检查设置信息是否正确<br>
若一切正确但无法连接，参考<a href="https://yeming.site/post/gridea_help/">这篇文章</a><br>
然后点击左下角的<strong>同步</strong></p>
</blockquote>
<h2 id="42-主题美化">4.2 主题美化</h2>
<p>将网盘资源中的<em>gridea-themes</em>解压，把里面的每个单文件夹（如song、jia、lin等）放入<mark>站点源文件夹</mark>中<strong>如下图</strong><br>
<img src="https://s2.ax1x.com/2020/02/28/3BsK9P.jpg" alt="theme" loading="lazy"><br>
<img src="https://s2.ax1x.com/2020/02/28/3Bsnht.jpg" alt="theme0" loading="lazy"><br>
重启gridea后就可以选择主题了 <s>我使用的是Chic</s></p>
<h2 id="43-评论设置">4.3 评论设置</h2>
<h3 id="431-新建一个仓库">4.3.1 新建一个仓库</h3>
<p>设置默认，命名为blog-comment</p>
<h3 id="432-新建gitalk-app">4.3.2 新建Gitalk App</h3>
<p>进入github账户的<strong>开发者设置</strong><br>
<img src="https://s2.ax1x.com/2020/02/28/3By18x.jpg" alt="comment" loading="lazy"><br>
新建App，设置如下<br>
<img src="https://s2.ax1x.com/2020/02/28/3BcN4A.jpg" alt="comment0" loading="lazy"><br>
保存两行代码<br>
<img src="https://s2.ax1x.com/2020/02/28/3BctNd.jpg" alt="comment1" loading="lazy"></p>
<h3 id="433-连接至博客">4.3.3 连接至博客</h3>
<p>设置如下：<br>
<img src="https://s2.ax1x.com/2020/02/28/3BgExP.jpg" alt="blog" loading="lazy"><br>
<code>每篇文章都需要初始化评论，新文章评论区github登陆</code></p>
<hr>
<h1 id="5-编辑博文">5 编辑博文</h1>
<p>使用markdown编辑，语法<a href="https://www.jianshu.com/p/q81RER">参考</a><br>
<mark>这个应用不会自动同步，需要点击同步按钮</mark></p>
<hr>
<p>如果想配置自己的域名，可以移步至<a href="https://diego.plus/post/gridea-jing-tai-bo-ke-shi-yong-cname-yi-ji-xiang-guan-pei-zhi/">我的这篇博客</a><br>
感谢阅读本蒟蒻的博客，如有问题请在下方评论<br>
欢迎参观我的<a href="https://diego3893.github.io">博客</a></p>
]]></content>
    </entry>
</feed>