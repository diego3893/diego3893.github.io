{"posts":[{"title":"Windows中的Linux","content":"Linux子系统似乎是虚拟机的完美替代方案！ 1 开启WSL支持 在控制面板进入程序 进入启用或关闭Windows功能 打开适用于Linux的Windows子系统并重启电脑 2 下载Linux子系统 在Windows Store中安装Ubuntu 20.04 LTS 3 安装完成后开始使用 ","link":"http://diego3893.github.io/post/windows-zhong-de-linux/"},{"title":"QduOJ安装指南","content":"1 安装环境 Ubuntu20.04Server 本校服务器 2 前置加速 2.1 更换apt源 p.s. vi/vim进入Insert模式开始编辑：i，退出Insert模式进入Normal模式：Esc，Normal模式下保存并退出：:wq sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak # 备份源文件 sudo vi /etc/apt/sources.list # 编辑apt源的列表文件 把文件内容全部删除后输入以下内容： deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal universe deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates universe deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security universe deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security multiverse 保存退出后输入： sudo apt update # 更新源列表 sudo apt upgrade # 更新系统 sudo apt install vim # 安装vim 2.2 加速pip cd # 回到~目录 mkdir .pip &amp;&amp; cd .pip # 创建.pip文件夹并进入其子目录 vim pip.conf # 新建文件pip.conf并编辑 进入Insert模式输入以下： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple :wq保存退出 2.3 加速docker sudo vim /etc/docker/daemon.json 输入以下： { &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;] } 保存并退出 2.4 修改hosts以加速github（可选） sudo vim /etc/hosts 输入以下： 151.101.72.249 github.global.ssl.fastly.net 192.30.253.112 github.com 保存并退出 3 开始安装 3.1 设置root用户 # 确认是否有root用户 su # 切换至root # 如果提示密码不对或无用户，进行以下，否则略过之 sudo passwd root # 创建root，接下来自己设定密码 # 设置完成后 su # 进入root，接下来请始终保持在root中 3.2 安装依赖 apt-get update &amp;&amp; sudo apt-get install -y vim python3-pip curl git pip3 install --upgrade pip pip install docker-compose 3.3 安装docker 国内请使用：sudo curl -sSL https://get.daocloud.io/docker | sh 国外请使用：sudo curl -sSL get.docker.com | sh 附上docker官方文档：传送门 p.s. 此处可能耗时较长 3.4 部署OJ cd /home # 回到~目录 git clone -b 2.0 https://github.com/Harry-zklcdc/OnlineJudgeDeploy.git &amp;&amp; cd OnlineJudgeDeploy # 克隆项目 docker-compose up -d # 部署项目 3.5 检查部署是否成功 docker ps -a 当看到所有的容器的状态没有 unhealthy 或 Exited (x) xxx 就代表 OJ 已经启动成功 3.6 OJ登入设置 初始用户：root 密码：rootroot 4 修改&amp;美化 4.1 修改端口 修改/home/OnlineJudgeDeploy/中的docker-compose.yml 在ports关键词下，大约85行左右 # 原配置 ports: - &quot;0.0.0.0:80:8000&quot; # http - &quot;0.0.0.0:443:1443&quot; # https # 更改后 ports: - &quot;0.0.0.0:81:8000&quot; - &quot;0.0.0.0:443:1443&quot; 然后再次 su docker-compose up -d 即可 4.2 使用看板娘（可选） cd /home/OnlineJudgeDeploy/data/forum/api/live2d/model/ git clone https://gitee.com/zklcdc/live2d_models.git &amp;&amp; cd live2d_models # 克隆模型到本地 cp -r * ../ # 将所有文件复制到上级文件夹 cd ../ &amp;&amp; cp model_list.json ../ # 把列表文件复制到live2d文件夹中 打开网页，just enjoy 4.3 修改网页icon 在/home/OnlineJudgeDeploy/data/backend/public/website/中，用自己的图片替换favicon.ico即可 4.4 修改默认头像 在/home/OnlineJudgeDeploy/data/backend/public/avatar/中，用自己的图片替换default.png即可 5 参考项目 Harry-zklcdc/OnlineJudgeDeploy QingdaoU/OnlineJudgeDeploy QduOJ用户文档 山东省桓台第一中学OJ ","link":"http://diego3893.github.io/post/qduoj-an-zhuang-zhi-nan/"},{"title":"题解 P1135 【奇怪的电梯】","content":"典型的BFS题 大体思路 把楼层抽象为一个一维数组，对应K值为行走步数，进行搜索 注：蒟蒻使用数组模拟队列 上代码： （有注释 ） #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int head, tail; //头尾指针 struct lift{ //存储电梯楼层 int book; //标记 int cnt; //步数 int k; //K值 }l[201]; int a, b, n; //如题 int x; //临时数据存储 int map[1002]; //队列 int main() { //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d%d&quot;, &amp;n, &amp;a, &amp;b);//不多说 for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, &amp;l[i].k); l[i].cnt = 0, l[i].book = 0;//初始化 } head = 0, tail = 0; l[a].book = 1, l[a].cnt = 0; map[head] = a, ++tail; //初始点特殊处理 while(head &lt; tail) //若还能扩展 { x = map[head] + l[map[head]].k; //扩展方式1 if(x&gt;=1 &amp;&amp; x&lt;=n &amp;&amp; l[x].book == 0) //在范围以内且未到过 { map[tail++] = x; //入队 l[x].book = 1; //打标记 l[x].cnt = l[map[head]].cnt+1;//步数+1 } if(x == b)//剪枝1 { printf(&quot;%d&quot;, l[x].cnt); return 0; } x = map[head] - l[map[head]].k;//扩展方式2 if(x&gt;=1 &amp;&amp; x&lt;=n &amp;&amp; l[x].book == 0) { map[tail++] = x;//同上 l[x].book = 1; l[x].cnt = l[map[head]].cnt+1; } if(x == b)//剪枝2 { printf(&quot;%d&quot;, l[x].cnt); return 0; } ++head;//这个楼层扩展完毕，出队 } if(l[b].book == 0)//若无法到达 printf(&quot;-1&quot;); //fclose(stdin); return 0; } 若有不懂，可以和本蒟蒻一样，阅读《啊哈！算法》 ","link":"http://diego3893.github.io/post/ti-jie-p1135-qi-guai-de-dian-ti/"},{"title":"题解 P1164 【小A点菜】","content":"这是一道很水的dp题，但作为第一天学动态规划的蒟蒻还是提交了两遍/捂脸/ 看到前面dalao全部用文字叙述，今天我想介绍一种推状态转移方程的方法———— 表格法 本人直接用的样例，方便对照 通过表格可以直观看出方程 自认为小学找规律难度 具体数据表示啥我就不详细介绍了，应该都懂 还是上一下代码吧： #include&lt;cstdio&gt; using namespace std; const int maxm = 10005, maxn = 105; //数据范围 int cell[maxn][maxm], p[maxn]; int main() { int m, n; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); //看清输入顺序，我第一次就是把顺序搞反了 for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, &amp;p[i]); //输入价格 for(int i=1; i&lt;=n; ++i) //从第一道菜开始（表格第一列） for(int j=1; j&lt;=m; ++j) //从只剩一元钱开始直到符合输入的钱数（表格第一行） { if(j &lt; p[i]) //三个方程依次判断 cell[i][j] = cell[i-1][j]; if(j == p[i]) cell[i][j] = cell[i-1][j]+1; if(j &gt; p[i]) cell[i][j] = cell[i-1][j]+cell[i-1][j-p[i]]; } printf(&quot;%d&quot;, cell[n][m]); //由上表可得：右下角的数即为正解 return 0; //愉快的结束 } ","link":"http://diego3893.github.io/post/ti-jie-p1164-xiao-a-dian-cai/"},{"title":"题解 P1765 【手机_NOI导刊2010普及（10）】","content":"这道题其实很水，用一个整形数组存放每个字母的按键次数即可 附代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int l[26] = {1,2,3, 1,2,3, 1,2,3, 1,2,3, 1,2,3, 1,2,3,4, 1,2,3, 1,2,3,4}; //按键次数 int main() { char c[200]; while(gets(c)) //读入若干行句子（不要用scanf(&quot;%s&quot;, c)；和cin&gt;&gt;c;读到空格就要停 { int ans = 0; //按键次数总和 for(int i=0; i&lt;strlen(c); ++i) //遍历 { if(c[i]&lt;='z' &amp;&amp; c[i]&gt;='a') //如果是字母 ans += l[c[i]-'a']; //加上对应次数 else if(c[i] == ' ') //如果是空格 ++ans; //加一次 } printf(&quot;%d\\n&quot;, ans); //输出 } return 0; //愉快的结束 } ","link":"http://diego3893.github.io/post/ti-jie-p1765-shou-ji-_noi-dao-kan-2010-pu-ji-10/"},{"title":"题解 P4414 【[COCI2006-2007#2] ABC】","content":"用简化的桶排序，再用if判断输出就行 附AC代码： #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a, b, c, n[3], j = 0;//n为排序用数组，j为排序时下标 char s[3];//s为输出顺序 cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;//输入数据 cin&gt;&gt;s; for(int i=1; i&lt;=100; ++i)//循环排序【排序】 { if(i == a)//如果是a，就把它放在第一位（最小） { n[j] = a; ++j; continue; } if(i == b)//同上 { n[j] = b; ++j; continue; } if(i == c)//同上 { n[j] = c; ++j; continue; } if(j ==3)//如果三个数顺序已经排好，退出循环 break; } for(int i=0; i&lt;3; ++i)//选择输出【输出】 { if(s[i] == 'A')//检查顺序 cout&lt;&lt;n[0]; if(s[i] == 'B') cout&lt;&lt;n[1]; if(s[i] == 'C') cout&lt;&lt;n[2]; cout&lt;&lt;' '; } return 0;//结束程序 } ","link":"http://diego3893.github.io/post/ti-jie-p4414-coci2006-20072-abc/"},{"title":"题解 P1059 【明明的随机数】","content":"看到去重+排序（数据范围不是很大）直接用桶排序 上AC代码： #include&lt;bits/stdc++.h&gt; using namespace std; bool number[1000]; //1000个“桶” int main() { int N, sum = 0, s; cin&gt;&gt;N; for(int i = 1; i&lt;=N; ++i) { cin&gt;&gt;s;//读入数据 if(!number[s])//如果这个数没有出现过 { number[s] = 1;//标记为出现 ++sum;//计数器+1 } } cout&lt;&lt;sum&lt;&lt;endl;//输出不相同的数的个数 for(int i=0; i&lt;1000; ++i)//遍历数组 if(number[i])//如果出现过就输出 cout&lt;&lt;i&lt;&lt;' '; return 0;//结束程序 } ","link":"http://diego3893.github.io/post/ti-jie-p1059-ming-ming-de-sui-ji-shu/"},{"title":"题解 P1150 【Peter的烟】","content":"直接上AC代码： #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n, k, x = 1, sum = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;k);//输入 sum += n;//本来拥有的烟 while(x&gt;0) { x = n/k;//可以换x根 n = n-x*k+x;//剩下的烟蒂 sum += x;//加上换来的烟 } cout&lt;&lt;sum; return 0; } ","link":"http://diego3893.github.io/post/ti-jie-p1150-peter-de-yan/"},{"title":"题解 P3742  【umi的函数】","content":"AC代码： #include&lt;bits/stdc++.h&gt; using namespace std; char s[100],s1[100],s2[100];//s为y,s1为x,s2为z int n; int main() { cin&gt;&gt;n; for(int i=0;i&lt;n;i++)//输入 cin&gt;&gt;s1[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;s2[i]; for(int i=0;i&lt;n;i++) { if(s1[i]&lt;s2[i])//判断是否存在 { cout&lt;&lt;&quot;-1&quot;; return 0; } } for(int i=0;i&lt;n;i++) { if(s1[i]==s2[i]) { s[i]='z';//保证大于等于s1[i] } else s[i]=s2[i]; } puts(s);//输出 return 0; } ","link":"http://diego3893.github.io/post/ti-jie-p3742-umi-de-han-shu/"},{"title":"单链表实现----学生成绩查询系统","content":"代码注释较少，若给各位的阅读带来不便，请谅解 本人蒟蒻一枚，写得也是很不容易了，请多多鼓励 #include&lt;bits/stdc++.h&gt; using namespace std; void run(); //运行 void menu();//菜单 void Read();//读入 void Put();//全部输出 void Find();//查询 void Insert();//添加 void Delete(); //删除 void Len();//输出长度 void Save();//保存 void Empty();//清空 int Lenth();//求长度 void readData();//提取数据 void Data();//读取数据 struct node{ int number; char name[20]; int ch; int ma; int en; int to = 0; double av; node *next; }*head, *p, *r, a; int choose, member; bool f = 1, flag; int main() { head = new node; r = head; system(&quot;color 74&quot;); cout&lt;&lt;&quot;欢迎使用成绩查询系统\\nMADE BY DIEGO\\n&quot;; system(&quot;pause&quot;); system(&quot;cls&quot;); Data(); system(&quot;cls&quot;); while(f) { system(&quot;color f1&quot;); run(); } return 0; } void run() { menu(); system(&quot;cls&quot;); return; } void menu() { cout&lt;&lt;setw(50)&lt;&lt;&quot;MENU\\n&quot;; cout&lt;&lt;&quot;1：录入； 2：查询； 3：添加； 4：删除； 5：清空； 6：显示所有； 7：学生人数 8：保存并退出\\n&quot;; cout&lt;&lt;&quot;请输入您的选择：&quot;; scanf(&quot;%d&quot;, &amp;choose); switch(choose) { case 1:Read();break; case 2:Find();break; case 3:Insert();break; case 4:Delete();break; case 5:Empty();break; case 6:Put();break; case 7:Len();break; case 8:Save();break; } return; } void Read() { system(&quot;color f2&quot;); cout&lt;&lt;&quot;请输入人数：&quot;; scanf(&quot;%d&quot;, &amp;member); cout&lt;&lt;&quot;输入顺序为：学号 姓名(长度不超过20) 语文分数 数学分数 英语分数\\n&quot;; for(int i=1; i&lt;=member; ++i) { scanf(&quot;%d%s%d%d%d&quot;, &amp;a.number, &amp;a.name, &amp;a.ch, &amp;a.ma, &amp;a.en); p = new node; p-&gt;number = a.number; strcpy(p-&gt;name, a.name); p-&gt;ch = a.ch; p-&gt;ma = a.ma; p-&gt;en = a.en; p-&gt;to = a.ch+a.en+a.ma; p-&gt;av = p-&gt;to/3.0; p-&gt;next = NULL; r-&gt;next = p; r = p; } cout&lt;&lt;&quot;录入完成\\n\\n&quot;; system(&quot;pause&quot;); return; } void Len() { system(&quot;color f3&quot;); cout&lt;&lt;&quot;学生人数为：&quot;; int n = 0; node *s = head; while(s != NULL) { ++n; s = s-&gt;next; } cout&lt;&lt;n-1&lt;&lt;endl&lt;&lt;endl; system(&quot;pause&quot;); return; } void Delete() { int g; system(&quot;color f5&quot;); cout&lt;&lt;&quot;请输入删除结点编号：&quot;; scanf(&quot;%d&quot;, &amp;g); node *x, *s; x = head; int j = 0; while(x-&gt;next!=NULL &amp;&amp; j&lt;g-1) { x = x-&gt;next; ++j; } if(x-&gt;next == NULL) printf(&quot;cannot find this one&quot;); else { s = x-&gt;next; x-&gt;next = s-&gt;next; free(s); cout&lt;&lt;&quot;删除成功\\n\\n&quot;; } system(&quot;pause&quot;); return; } void Insert() { int d; system(&quot;color f6&quot;); cout&lt;&lt;&quot;请输入需添加的后一个结点位置：&quot;; scanf(&quot;%d&quot;, &amp;d); cout&lt;&lt;&quot;请输入数据（格式同录入数据）：&quot;; node *x, *s; x = head; int j = 0; while(x!=NULL &amp;&amp; j&lt;d-1) { x = x-&gt;next; ++j; } if(x == NULL) printf(&quot;cannot find this one&quot;); else { s = new node; scanf(&quot;%d%s%d%d%d&quot;, &amp;a.number, &amp;a.name, &amp;a.ch, &amp;a.ma, &amp;a.en); s-&gt;number = a.number; strcpy(s-&gt;name, a.name); s-&gt;ch = a.ch; s-&gt;ma = a.ma; s-&gt;en = a.en; s-&gt;to = a.ch+a.en+a.ma; s-&gt;av = s-&gt;to/3.0; s-&gt;next = x-&gt;next; x-&gt;next = s; cout&lt;&lt;&quot;添加成功\\n\\n&quot;; } system(&quot;pause&quot;); return; } void Put() { system(&quot;color f9&quot;); if(Lenth() == 0) { cout&lt;&lt;&quot;无数据\\n\\n&quot;; system(&quot;pause&quot;); return; } cout&lt;&lt;&quot;输出顺序为：学号 姓名 语文分数 数学分数 英语分数 总分 平均分\\n&quot;; p = head-&gt;next; while(p-&gt;next != NULL) { printf(&quot;%d &quot;, p-&gt;number); cout&lt;&lt;p-&gt;name; printf(&quot; %d %d %d %d %.2f\\n&quot;, p-&gt;ch, p-&gt;ma, p-&gt;en, p-&gt;to, p-&gt;av); p = p-&gt;next; } printf(&quot;%d &quot;, p-&gt;number); cout&lt;&lt;p-&gt;name; printf(&quot; %d %d %d %d %.2f\\n&quot;, p-&gt;ch, p-&gt;ma, p-&gt;en, p-&gt;to, p-&gt;av); cout&lt;&lt;&quot;\\n&quot;; system(&quot;pause&quot;); return; } void Find() { int pi; system(&quot;color f8&quot;); cout&lt;&lt;&quot;请输入结点位置：&quot;; scanf(&quot;%d&quot;, &amp;pi); node *s = head-&gt;next; int j = 1; while(s!=NULL &amp;&amp; j&lt;pi) { s = s-&gt;next; ++j; } if(s!=NULL &amp;&amp; j==pi) { printf(&quot;%d &quot;, s-&gt;number); cout&lt;&lt;s-&gt;name; printf(&quot; %d %d %d %d %.2f\\n&quot;, s-&gt;ch, s-&gt;ma, s-&gt;en, s-&gt;to, s-&gt;av); } else cout&lt;&lt;&quot;cannot find this one&quot;; cout&lt;&lt;&quot;\\n\\n&quot;; system(&quot;pause&quot;); return; } int Lenth() { int n = 0; node *s = head; while(s != NULL) { ++n; s = s-&gt;next; } return n-1; } void Empty() { system(&quot;color f5&quot;); node *x, *s; x = head; while(x-&gt;next!=NULL) { s = x-&gt;next; x-&gt;next = s-&gt;next; free(s); } free(x); cout&lt;&lt;&quot;系统已清空\\n\\n&quot;; system(&quot;pause&quot;); return; } void Save() { system(&quot;color 7C&quot;); freopen(&quot;score.txt&quot;, &quot;w&quot;, stdout); printf(&quot;%d\\n&quot;, Lenth()); p = head-&gt;next; while(p-&gt;next != NULL) { printf(&quot;%d &quot;, p-&gt;number); cout&lt;&lt;p-&gt;name; printf(&quot; %d %d %d %d %.2f\\n&quot;, p-&gt;ch, p-&gt;ma, p-&gt;en, p-&gt;to, p-&gt;av); p = p-&gt;next; } printf(&quot;%d &quot;, p-&gt;number); cout&lt;&lt;p-&gt;name; printf(&quot; %d %d %d %d %.2f\\n&quot;, p-&gt;ch, p-&gt;ma, p-&gt;en, p-&gt;to, p-&gt;av); fclose(stdout); freopen(&quot;CON&quot;, &quot;w&quot;, stdout); cout&lt;&lt;&quot;保存成功\\n\\n蒟蒻代码，感谢使用\\n&quot;; f = 0; return; } void Data() { system(&quot;color 70&quot;); cout&lt;&lt;&quot;是否读取数据?(1 是,0 否):&quot;; cin&gt;&gt;flag; if(flag) { readData(); cout&lt;&lt;&quot;读取成功\\n&quot;; } else cout&lt;&lt;&quot;未读取数据\\n&quot;; system(&quot;pause&quot;); return; } void readData() { freopen(&quot;score.txt&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;member); for(int i=1; i&lt;=member; ++i) { scanf(&quot;%d%s%d%d%d%d%f&quot;, &amp;a.number, &amp;a.name, &amp;a.ch, &amp;a.ma, &amp;a.en, &amp;a.to, &amp;a.av); p = new node; p-&gt;number = a.number; strcpy(p-&gt;name, a.name); p-&gt;ch = a.ch; p-&gt;ma = a.ma; p-&gt;en = a.en; p-&gt;to = a.to; p-&gt;av = a.av; p-&gt;next = NULL; r-&gt;next = p; r = p; } fclose(stdin); freopen(&quot;CON&quot;, &quot;r&quot;, stdin); return; } ","link":"http://diego3893.github.io/post/dan-lian-biao-shi-xian-xue-sheng-cheng-ji-cha-xun-xi-tong/"},{"title":"deepin安装Lemon","content":"测评机乃OI之神器也！于Linux安装之实属重要！ 下载资源 原项目： Project_LemonLime 也可以在码云下载： https://gitee.com/oierzcx/Project_LemonLime 本教程有视频 本人辛苦录制11分钟的教学视频： https://www.bilibili.com/video/BV1ei4y1t7yR 安装 安装依赖 sudo apt install qt5-default build-essential sudo apt install git sudo apt install g++ 编译 cd 源码目录 g++ watcher_unix.cpp -o watcher_unix -O2 qmake lemon.pro make 似乎可装可不装 sudo apt install qtcreator 设置全局开启 cd 源码目录 sudo cp lemon /usr/bin 效果 ","link":"http://diego3893.github.io/post/deepin-an-zhuang-lemon/"},{"title":"Deepin美化笔记","content":"deepin已经很好看了，但还可以美化！ Conky参上！ 安装Conky 安装Conky组件 sudo apt-get install conky-all 安装Conky管理器 wget --no-check-certificate https://github.com/teejee2008/conky-manager/releases/download/v2.4/conky-manager-v2.4-amd64.run 或者在这里下载conky-manager-v2.4-amd64.run，重命名为conky-manager-v2.4-amd64.run - 给予权限 chmod +x ./conky-manager-v2.4-amd64.run - 安装 sudo ./conky-manager-v2.4-amd64.run 创建组件 到.conky目录下，新建组件文件 cd ~/.conky sudo touch deepin_conky sudo deepin-editor deepin_conky 设置组件，将以下内容复制到deepin_conky中并保存 default_color white double_buffer yes no_buffers yes update_interval 1.0 total_run_times 0 own_window yes own_window_type normal own_window_transparent yes own_window_hints undecorated,below,sticky,skip_taskbar,skip_pager own_window_colour 000000 own_window_argb_visual yes own_window_argb_value 0 double_buffer yes draw_shades yes draw_outline no draw_borders no draw_graph_borders n0 minimum_size 300 1 maximum_width 406 default_color ffffff default_shade_color 000000 default_outline_color 000000 alignment top_right gap_x 6 gap_y 5 cpu_avg_samples 2 override_utf8_locale no uppercase no # set to yes if you want all text to be in uppercase use_spacer no use_xft yes xftfont WenQuanYi Zen Hei:pixelsize=12 override_utf8_locale yes use_spacer no minimum_size 300 1 TEXT ${font LCD:style=Bold:pixelsize=40}${alignc}${time %I:%M:%S} ${font LCD:style=Bold:pixelsize=20}${time %Y年%b%d日 星期%a}${alignc} ${font WenQuanYi Zen Hei:pixelsize=14} ${color #98c2c7}姓名: ${color}$alignr Diego ${color #98c2c7}邮箱: ${color}$alignr 3013006997@qq.com ${color #98c2c7}内核: ${color}$alignr$kernel ${color #98c2c7}已开机: ${color}$alignr$uptime ${color #98c2c7}CPU使用率: ${color}$cpu% $cpubar CPU1 温度: $alignr${exec sensors | grep 'Core 0' | cut -c17-25} CPU2 温度: $alignr${exec sensors | grep 'Core 1' | cut -c17-25} ${color #98c2c7}CPU占用:${color} ${top name 1} ${alignr}${top cpu 1} ${top name 2} ${alignr}${top cpu 2} ${top name 3} ${alignr}${top cpu 3} ${top name 4} ${alignr}${top cpu 4} ${top name 5} ${alignr}${top cpu 5} ${top name 6} ${alignr}${top cpu 6} ${color #98c2c7}物理内存：${color}${alignr}$mem / $memmax ${membar} ${color #98c2c7}根分区: ${color}${alignr}${fs_free /} / ${fs_size /} ${fs_bar 4 /} ${color #98c2c7}Home分区: ${color}${alignr}${fs_free /home} / ${fs_size /home} ${fs_bar 4 /home} ${color #98c2c7}网络使用:${color} 下载速度:$alignr${downspeed wlp3s0} k/s 上传速度:$alignr${upspeed wlp3s0} k/s ${downspeedgraph wlp3s0 324D23 77B753} 在管理器勾选即可 设置开机自启 打开第一个选项即可 为什么这么麻烦？ Conky原生的组件对deepin并不友好，所以…… 问题修复 如果CPU温度无法显示 请安装一个东西： sudo apt-get install lm-sensors ","link":"http://diego3893.github.io/post/deepin-mei-hua-bi-ji/"},{"title":"DeepinV20网速慢的解决方法","content":"这个可能是beta的小问题 终端输入： sudo deepin-editor /etc/modprobe.d/iwlwifi.conf 将options iwlwifi 11n_disable=1 bt_coex_active=0 power_save=0 swcrypto=1 中的11n_disable=1修改为11n_disable=0 重启电脑 ","link":"http://diego3893.github.io/post/deepinv20-wang-su-man-de-jie-jue-fang-fa/"},{"title":"安利一个Linux第三方QQ音乐","content":"众所周知，Linux没有QQ音乐，wine下的QQ音乐会有各种奇奇怪怪的错误，所以，我们就有了CocoMusic! 安装包在此 https://ww.lanzous.com/ic1v69e 此为最新版 开始安装 以deepinv20为例 双击deb，开始安装，不过会安装失败（莫慌） 进入终端，输入以下 sudo apt --fix-broken install 开始享受吧！ 源项目 CoCoMusic ","link":"http://diego3893.github.io/post/an-li-yi-ge-linux-di-san-fang-qq-yin-le/"},{"title":"我有不一样的Bilibili！","content":"请先安装油猴，步骤详见：这里 开始安装 访问这个脚本页面 安装 开始使用 开始自定义吧！ 最终效果 ","link":"http://diego3893.github.io/post/wo-you-bu-yi-yang-de-bilibili/"},{"title":"Google Chrome的扩展安利","content":" AdBlock 广告拦截 Astar 免费高速梯子，够稳 Dmooji 弹幕君 YouTube弹幕助手 Dualsub YouTube双语字幕 IDM Integration Module IDM配套插件（要IDM的私信我） Infinity 新标签页 (Pro) 美化首页 pakku Bilibili弹幕过滤+合并 InstantView for YouTube™ 允许您在弹出窗口中打开YouTube视频 RSSHub Radar RSS订阅器 Tampermonkey BETA 红油猴，程序猿都知道脚本的厉害doge（黑油猴也可以） 更多脚本请见https://greasyfork.org/zh-CN/ 哔哩哔哩·猜你喜欢 如题…… 哔哩哔哩助手 多功能自定义Bilibili 扩展管理器 如题…… 沙拉查词 划词翻译 Github加速 最棒的镜像加速 ","link":"http://diego3893.github.io/post/google-chrome-de-kuo-zhan-an-li/"},{"title":"用Google Chrome科学上网","content":"免费畅游墙外世界！ 先放资源 谷歌访问助手.zip 将之下载 在Chrome中添加扩展 请先打开开发者模式 选择加载扩展 选中刚才下载文件夹中的master分支文件 如果出现下图，恭喜！您可以访问Google啦！ 开始挂梯子 先注册Google账号，此处略过 点击Chrome收藏栏中的应用，进入商店 搜索Astar，安装 梯子就挂好了！ 效果 支持美国，日本，加拿大等多个节点 速度也绝对不慢（下载大文件还是比较恼火的） 高清YouTube随便看！ ","link":"http://diego3893.github.io/post/yong-google-chrome-ke-xue-shang-wang/"},{"title":"[转载]Typecho无插件实现QQ评论回复","content":"作者：奥秘Sir 原文地址：https://blog.say521.cn/archives/369.html QQ添加订阅机器人2827803813 订阅自己博客的RSS地址，比如http://blog.diego.plus:2000/feed 命令为订阅 http://blog.diego.plus:2000/feed 订阅评论地址：RSS地址/comments 订阅 http://blog.diego.plus:2000/feed/comments 然后就可以使用啦！不过好像推送有些滞后诶…… ","link":"http://diego3893.github.io/post/zhuan-zai-typecho-wu-cha-jian-shi-xian-qq-ping-lun-hui-fu/"},{"title":"[博主]Cuckoo的更新须知","content":" 备份后台数据 备份独立页面模版 追番 相册 function.php中的代码段 热门文章 最新文章 sidebar.php中代码段 热门文章 最新文章 footer.php中的代码段 notice CSS样式 B站视频 打赏 文章页面 打赏 海报 封面图片random 暂时能想起的就这些…… ","link":"http://diego3893.github.io/post/bo-zhu-cuckoo-de-geng-xin-xu-zhi/"},{"title":"Typecho不使用插件实现“打赏”按钮","content":"添加CSS样式到CSS文件或者主题后台的自定义CSS： #QR{padding-top:20px;} #QR a{border:0} #QR img{width:180px;max-width:100%;display:inline-block;margin:.8em 2em 0 2em} #rewardButton{border:1px solid #ccc;line-height:36px;text-align:center;height:36px;display:block;border-radius:4px;-webkit-transition-duration:.4s;transition-duration:.4s;background-color:#fff;color:#999;margin:0 auto;padding:0 25px} 在post.php中添加如下： &lt;div style=&quot;padding: 10px 0; margin: 20px auto; width: 100%; font-size:16px; text-align: center;&quot;&gt; &lt;button id=&quot;rewardButton&quot; disable=&quot;enable&quot; onclick=&quot;var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}&quot;&gt; &lt;span&gt;打赏&lt;/span&gt; &lt;/button&gt; &lt;div id=&quot;QR&quot; style=&quot;display: none;&quot;&gt; &lt;div id=&quot;wechat&quot; style=&quot;display: inline-block&quot;&gt; &lt;a class=&quot;fancybox&quot; rel=&quot;group&quot;&gt;&lt;img id=&quot;wechat_qr&quot; src=&quot;http://blog.diego.plus:2000/images/pay/wx.png&quot; alt=&quot;Diego -&gt; WeChat Pay&quot;&gt;&lt;/a&gt; &lt;p&gt; 微信打赏 &lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;alipay&quot; style=&quot;display: inline-block&quot;&gt; &lt;a class=&quot;fancybox&quot; rel=&quot;group&quot;&gt;&lt;img id=&quot;alipay_qr&quot; src=&quot;http://blog.diego.plus:2000/images/pay/ali.jpg&quot; alt=&quot;Diego -&gt; Alipay&quot;&gt;&lt;/a&gt; &lt;p&gt; 支付宝打赏 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 至于怎么获取付款码，自行百度 代码不会改的，下方留言 ","link":"http://diego3893.github.io/post/typecho-bu-shi-yong-cha-jian-shi-xian-da-shang-an-niu/"},{"title":"Typecho文章内加载B站视频","content":"在Blog挂载Bilibili视频哟！ 效果查看：http://blog.diego.plus:2000/archives/315/ 先上CSS /*视频挂载*/ .iframe_video { position: relative; width: 100%; } @media only screen and (max-width: 767px) { .iframe_video { height: 15em; } } @media only screen and (min-width: 768px) and (max-width: 991px) { .iframe_video { height: 20em; } } @media only screen and (min-width: 992px) and (max-width: 1199px) { .iframe_video { height: 30em; } } @media only screen and (min-width: 1200px) { .iframe_video { height: 40em; } } .iframe_cross { position: relative; width: 100%; height: 0; padding-bottom: 75% } .iframe_cross iframe { position: absolute; width: 100%; height: 100%; left: 0; top: 0 } 具体添加方式：自定义CSS中粘贴 Cuckoo添加方式：将CSS复制到Cuckoo/assets/css/cuckoo.min.css中即可 在B站视频找到嵌入代码然后复制 添加class=&quot;iframe_video&quot; &lt;iframe class=&quot;iframe_video&quot; src=&quot;//player.bilibili.com/player.html?aid=752860673&amp;bvid=BV1Dk4y1R7yF&amp;cid=180022793&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; 此样式由[@iBoy](http://120.79.194.69/)提供","link":"http://diego3893.github.io/post/typecho-wen-zhang-nei-jia-zai-b-zhan-shi-pin/"},{"title":"Deepin20食用笔记","content":"本人早起一直用的Deepin15，但后来因为硬盘吃紧，便将之卸载，此次重新安装，特写此文以记之。 1 准备工作 1.1 制作启动盘 到官网下载最新的镜像deepin-20Beta-desktop-amd64.iso 使用deepin-boot-maker.zip制作启动盘 选择镜像 选择U盘 1.2 分区 Win分区自行百度，我分的40G，但如果只是体验的话，15G应该足够了，毕竟系统只有6G 2 开始安装 重启电脑，U盘启动，我的电脑是连点F12，不同电脑可能不一样 语言选中文 选择手动安装，点击最右侧的小按钮 文件系统：ext4，挂载根目录，新建 然后就可以开始安装啦！ 3 deepin20体验 深度UI的美观一直是在操作系统中居于前茅的。这次从15.11到20beta改动确实很大————保留了deepin和UOS的特点 软件仓库换成debian10了，更稳了，省去换源的步骤 内核换成最新的5.3 总得来说，这次大更新深度公司很用心哦 4 卸载deepin 查看：https://blog.csdn.net/qq_35379989/article/details/83515882 ","link":"http://diego3893.github.io/post/deepin20-shi-yong-bi-ji/"},{"title":"用群晖Nas搭建Typecho博客","content":"记自己的typecho入坑过程 软件安装 共五个：Apache2.4，PHP5.6，Web Station，MariaDB 5，PhpMyAdmin MariaDB注意事项 数据库密码：务必记住 务必勾选安装完成后启动 下载Blog源码 前往官网下载 开始部署 数据库 登录数据库 新建数据表 虚拟主机 在Web新建一个typecho文件夹，解压源码，将build里的文件拷贝至typecho文件夹内 设置权限 设置后端 php设置 创建虚拟主机 Blog安装 IP:端口/install.php访问 部分需要注意配置如下 如果遇到问题，请留言哦 ","link":"http://diego3893.github.io/post/yong-qun-hui-nas-da-jian-typecho-bo-ke/"},{"title":"HTML自学笔记-2020.4.17","content":"本蒟蒻开始自学HTML了！ 标题 &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;h2&gt;这是一个标题&lt;/h2&gt; &lt;h3&gt;这是一个标题&lt;/h3&gt; 段落 &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另外一个段落。&lt;/p&gt; 超链接 &lt;a href=&quot;#&quot; title=&quot;X&quot; target=&quot;_blank&quot;&gt;这是一个链接&lt;/a&gt; _blank为新页面打开 _self为本页面打开 图片 &lt;img src=&quot;/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt; 换行 &lt;br&gt; 头部 字符编码 &lt;meta charset=&quot;utf-8&quot;&gt; 网页标题 &lt;title&gt;标题&lt;/title&gt; 基本链接地址 &lt;base href=&quot;#&quot; target=&quot;_blank&quot;&gt; 关联外部资源 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt; 网页渲染 &lt;style type=&quot;text/css&quot;&gt; body {background-color:yellow} p {color:blue} &lt;/style&gt; 一些基本的元数据，这些东西不会显示，但会被解析 &lt;!--搜索引擎关键词--&gt; &lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt; &lt;!--描述--&gt; &lt;meta name=&quot;description&quot; content=&quot;编程 自学&quot;&gt; &lt;!--作者--&gt; &lt;meta name=&quot;author&quot; content=&quot;Diego&quot;&gt; &lt;!--刷新时间--&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt; 加载JS脚本 &lt;script&gt;&lt;/script&gt; 代码基本格式 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;!--内容--&gt; &lt;/head&gt; &lt;body&gt; &lt;!--内容--&gt; &lt;/body&gt; &lt;/html&gt; ","link":"http://diego3893.github.io/post/html-zi-xue-bi-ji-2020417/"},{"title":"[转载]在Gridea博客中加入看板娘","content":"原文作者：wherelse 原文地址：https://wherelse.cc/post/add-live2d-in-the-gridea-theme/ 项目文件 Live2D-for-Gridea 基本食用方法 将文件夹放到\\主题\\assets\\media中 在主题的index.ejs的&lt;head&gt;或&lt;body&gt;添加如下代码 &lt;script src=&quot;./media/live2d/autoload.js&quot;&gt;&lt;/script&gt; 进阶食用方法 开关设置 在config.json最后添加 { &quot;name&quot;: &quot;Live2D&quot;, &quot;label&quot;: &quot;Live2D看板娘&quot;, &quot;group&quot;: &quot;Live2D&quot;, &quot;value&quot;: true, &quot;type&quot;: &quot;switch&quot;, &quot;note&quot;: &quot;若不需要，可关闭以加快页面加载速度&quot; } index.ejs中代码改为： &lt;% if (site.customConfig.Live2D){ %&gt; &lt;script src=&quot;./media/live2d/autoload.js&quot;&gt;&lt;/script&gt; &lt;% } %&gt; 自定义内容 在waifu-tips.json和waifu-tips.js中可以自定义看板娘的文字内容，按需更改。 ","link":"http://diego3893.github.io/post/zhuan-zai-zai-gridea-bo-ke-zhong-jia-ru-kan-ban-niang/"},{"title":"[转载]GHbutton1.0.4使用方法","content":"本文转自：羽中大佬 https://www.yzmb.me/archives/net/github-btn-typecho 参数配置 user：用户名 type：标签类型 star：星标项目 download：下载项目 watch：跟进项目 fork：拷贝项目 follow：关注作者 issue：提交问题 count：计数 size：大/小按钮 lang：按钮语言cn/en width：缺省宽度 正文使用 无参数：&lt;gb&gt;jzwalk/GHbutton&lt;/gb&gt; 有参数： &lt;gb user=&quot;jzwalk&quot; type=&quot;download&quot; count=&quot;1&quot; size=&quot;1&quot; lang=&quot;cn&quot; width=&quot;370&quot;&gt; GHbutton &lt;/gb&gt; 正文外使用 添加勾子 举例：&lt;?php $this-&gt;ghbutton('jzwalk/GHbutton', 'type=&quot;follow&quot;'); ?&gt; 参数含义同上 ","link":"http://diego3893.github.io/post/zhuan-zai-ghbutton104-shi-yong-fang-fa/"},{"title":"[转载]博客文章编辑技巧","content":" 版权属于：路讯先生 本文链接：https://lxxs.xyz/archives/17/ 加密 第一种 &lt;script type=&quot;text/javascript&quot;&gt; function password() { var testV = 1; var pass1 = prompt('请输入密码',''); while (testV &lt; 3) { if (!pass1) top.location='https://blog.lxxs.xyz';//为防止在新标签页产生问题的修改 if (pass1 == &quot;123&quot;) { alert('密码正确，'); break; } testV+=1; var pass1 = prompt('emm，你这么想看？？谔谔谔:'); } if (pass1!=&quot;password&quot; &amp; testV ==3) top.location='https://blog.lxxs.xyz';//此为防止在新标签页产生问题的修改 return &quot; &quot;; } document.write(password()); &lt;/script&gt; &lt;!--下面添加你要显示的内容或者代码--&gt; 显示内容！ 直接将以上内容放到文章最开始的地方 第二种 适合手动加密某个网页 &lt;script type=&quot;text/javascript&quot;&gt; loopy() function loopy() { var sWord =&quot;&quot; while (sWord != &quot;123&quot;) {//设置密码 sWord = prompt(&quot;输入正确密码才能登陆!&quot;) } alert(&quot;欢迎访问&quot;) } &lt;/script&gt; &lt;!--下面添加你要显示的内容或者代码--&gt; 内容! 第三种 网页跳转 &lt;script type=&quot;text/javascript&quot;&gt; function password() { var testV = 1; var pass1 = prompt('请输入密码:',''); while (testV &lt; 3) { if (!pass1) history.go(-1); if (pass1 == &quot;123&quot;) {//设置密码 alert('口令正确，进行跳转'); window.location.href=&quot;http://xxinn.cn&quot;;//添加你要跳转的页面 break; } testV+=1; var pass1 = prompt('密码错误',''); } if (pass1!=&quot;password&quot; &amp; testV ==3) history.go(-1); return &quot; &quot;; } document.write(password()); &lt;/script&gt; 插入Bilibili视频 &lt;div style=&quot;position: relative; padding: 30% 45%;&quot;&gt; &lt;iframe style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot; src=&quot;https://player.bilibili.com/player.html?aid=70993038&amp;cid=123009768&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=0&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 图片排版 一行多张 &lt;table&gt; &lt;tr&gt; &lt;td &gt;&lt;center&gt;&lt;img src=&quot;link&quot; &gt;name&lt;/center&gt;&lt;/td&gt; &lt;td &gt;&lt;center&gt;&lt;img src=&quot;link&quot; &gt;name&lt;/center&gt;&lt;/td&gt; ······· &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;center&gt;&lt;img src=&quot;link&quot; &gt;name&lt;/center&gt;&lt;/td&gt; &lt;td &gt;&lt;center&gt;&lt;img src=&quot;link&quot; &gt;name&lt;/center&gt; &lt;/td&gt; ······· &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;center&gt;&lt;img src=&quot;link&quot; &gt; name&lt;/center&gt;&lt;/td&gt; &lt;td&gt;&lt;center&gt;&lt;img src=&quot;link&quot; &gt; name&lt;/center&gt;&lt;/td&gt; ······· &lt;/tr&gt; ········ &lt;/table&gt; 一行一张 &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;center&gt;&lt;img src=&quot;link&quot; /&gt;&lt;/center&gt; &lt;center&gt;name&lt;/center&gt; &lt;/td&gt; &lt;tr&gt; &lt;/table&gt; 折叠显示 &lt;details&gt; &lt;summary&gt;点击查看&lt;/summary&gt; 内容 &lt;/details&gt; 变色字体 &lt;font color='red'&gt;内容&lt;/font&gt; ","link":"http://diego3893.github.io/post/zhuan-zai-bo-ke-wen-zhang-bian-ji-ji-qiao/"},{"title":"Windows使用make的方法","content":"使用MinGW安装gcc/g++，make，debug等 下载MinGW 前往官网下载 我下载好的安装包mingw-get-setup.zip 开始安装 保持默认 continue 勾选mingw32-base Apply：开始安装 报错的解决办法 我的是gdb和make直接failed 下载这两个文件： make-3.82-5-mingw32-bin.zip gdb-7.6.1-1-mingw32-bin.zip 本文只提供make的解决方案 解包第一个make-3.82-5-mingw32-bin.zip，将mingw32-make.exe重命名为make.exe，将其拷贝至MinGW安装目录的bin文件夹中 添加环境变量：你的MinGW的bin文件夹，如：C:\\MinGW\\bin，添加方法自行百度 打开cmd，输入make --version，如果输出如下： GNU Make 3.82 Built for i386-pc-mingw32 Copyright (C) 2010 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. 那么make就可以使用啦！ 附上MinGW单独包的下载地址：https://sourceforge.net/projects/mingw/files/MinGW/Extension/ ","link":"http://diego3893.github.io/post/windows-shi-yong-make-de-fang-fa/"},{"title":"Python3.7安装turtle图形化包","content":"3.7安装turtle会报错，一番折腾终于解决了！ Python安装 参考这篇博文 文件下载 turtle-0.0.2.zip 请务必下载此安装包，官方的不支持3.x版本 我的修改版是支持的，不用担心有问题，毕竟修改方式是CSDN上扒来的 解压放桌面上 开始安装 打开管理员CMD 输入pip install Twisted 再输入pip install -e C:\\Users\\UserName\\Desktop\\turtle-0.0.2 完成后 import turtle turtle.pensize(2) turtle.penup() turtle.pendown() turtle.fd(100) turtle.fd(-100) turtle.rt(90) turtle.fd(100) turtle.lt(-90) turtle.fd(100) turtle.done() 另存为turtle.py 双击运行，会生成*pycache*文件夹和其中的xxx.pyc文件，双击pyc运行动画 开始玩耍吧！ ","link":"http://diego3893.github.io/post/python37-an-zhuang-turtle-tu-xing-hua-bao/"},{"title":"自己写的小游戏--五子棋","content":"直接上代码吧 #include&lt;bits/stdc++.h&gt; using namespace std; const int X = 21; //棋盘行数 const int Y = 21; //棋盘列数 char p[X][Y]; //定义棋盘 int m=0;//定义临时点，保存输入坐标 int n=0; void display() //输出棋盘 { for(int i=0; i&lt;X; i++) cout&lt;&lt;setw(3)&lt;&lt;setfill(' ')&lt;&lt;i; cout&lt;&lt;endl; for(int i=1; i&lt;Y; i++) { cout&lt;&lt;setw(3)&lt;&lt;setfill(' ')&lt;&lt;i; for(int j=1;j&lt;X;j++) cout&lt;&lt;setw(3)&lt;&lt;setfill(' ')&lt;&lt;p[i][j]; cout&lt;&lt;endl; } } void black() //黑方落子 { cout&lt;&lt;&quot;请黑方输入落子位置：\\n&quot; &lt;&lt;&quot;请输入落子的行数：&quot;; cin&gt;&gt;m; cout&lt;&lt;&quot;请输入落子的列数：&quot;; cin&gt;&gt;n; if(m&lt;=0||m&gt;=X||n&gt;=Y||n&lt;=0) { cout&lt;&lt;&quot;超出棋盘范围，请重新输入正确坐标！\\n&quot;; black(); } else if((p[m][n]=='#')||p[m][n]=='*') { cout&lt;&lt;&quot;该点已有棋子，请重新选取落子点！\\n&quot;; black(); } else p[m][n]='#'; //黑方用#来表示 system(&quot;cls&quot;); display(); } void white() //白方落子 { cout&lt;&lt;&quot;请红方输入落子位置：\\n&quot;; cout&lt;&lt;&quot;请输入落子的行数：&quot;; cin&gt;&gt;m; cout&lt;&lt;&quot;请输入落子的列数：&quot;; cin&gt;&gt;n; if(m&gt;=X||m&lt;=0||n&lt;=0||n&gt;=Y) { cout&lt;&lt;&quot;超出棋盘范围，请重新输入正确坐标！\\n&quot;; white(); } else if((p[m][n]=='#')||p[m][n]=='*') { cout&lt;&lt;&quot;该点已有棋子，请重新选取落子点！\\n&quot;; white(); } else p[m][n]='*'; //白方用*来表示 system(&quot;cls&quot;); display(); } int evalue() //只需要判断落子点为中心的九点“米”字是否连续即可 { int k = 0,r = 0; /*斜线判断*/ for(k=3;k&lt;X-2;k++) //两条，其中的p[k][r]!='-'是排除空子的情况 { for(r=3;r&lt;Y-2;r++) { if(p[k][r]!='-'&amp;&amp;p[k-2][r-2]==p[k][r]&amp;&amp;p[k-1][r-1]==p[k][r]&amp;&amp;p[k+1][r+1]==p[k][r]&amp;&amp;p[k+2][r+2]==p[k][r]) return 1; else if(p[k][r]!='-'&amp;&amp;p[k+2][r-2]==p[k][r]&amp;&amp;p[k+1][r-1]==p[k][r]&amp;&amp;p[k-1][r+1]==p[k][r]&amp;&amp;p[k-2][r+2]==p[k][r]) return 1; } } /*横线判断*/ for(k=1;k&lt;X;k++) //p[k][r]!='-'是排除空子的情况 for(r=3;r&lt;Y-2;r++) if(p[k][r]!='-'&amp;&amp;p[k][r-2]==p[k][r]&amp;&amp;p[k][r-1]==p[k][r]&amp;&amp;p[k][r+1]==p[k][r]&amp;&amp;p[k][r+2]==p[k][r]) return 1; /*竖线判断*/ for(k=3;k&lt;X-2;k++) //p[k][r]!='-'是排除空子的情况 for(r=1;r&lt;Y;r++) if(p[k][r]!='-'&amp;&amp;p[k-2][r]==p[k][r]&amp;&amp;p[k-1][r]==p[k][r]&amp;&amp;p[k+1][r]==p[k][r]&amp;&amp;p[k+2][r]==p[k][r]) return 1; return 0; } int main() { memset(p,'-',441); //初始化为‘-’ cout&lt;&lt;&quot;欢迎使用简易双人对战五子棋游戏\\n&quot;&lt;&lt;&quot;黑子为#，白子为*\\n&quot; &lt;&lt;&quot;Powered by Diego\\n&quot;; system(&quot;pause&quot;); system(&quot;cls&quot;); display(); while(1) { white(); if(evalue()) { cout&lt;&lt;&quot;白方赢！\\n&quot;; break; } black(); if(evalue()) { cout&lt;&lt;&quot;黑方赢！\\n&quot;; break; } } return 0; } 转载请注意注明来源 ","link":"http://diego3893.github.io/post/zi-ji-xie-de-xiao-you-xi-wu-zi-qi/"},{"title":"安利Typecho插件","content":"轻量到绝望的Typecho因主题和插件而美丽doge 以下为本人使用的主题及插件，安利一下哦 插件 名称 简介 版本 指南 下载 APlayerAtBottom 在网站底部插入APlayer吸底播放器 1.1.0 查看 APlayerAtBottom.zip Access 获取访客信息，生成统计图表 2.0.2 查看 Access.zip AliceStyle 萌卜兔's 美化插件 2.6.2 查看 AliceStyle.zip ArticlePoster 为文章生成海报 1.0.6 q ArticlePoster.zip AutoLaTeX 自动渲染 LaTeX 公式 0.1.0 无 AutoLaTeX.zip Comment2Wechat 微信推送评论通知 1.1.0 查看 Comment2Wechat.zip EditorMD Markdown 编辑器 Editor.md for Typecho 1.4.0 查看 EditorMD.zip GHbutton 在文中嵌入GitHub项目按钮 1.0.4 查看 GHbutton.zip GoodLuck 随机跳转一篇文章 1.0.2 查看 GoodLuck.zip HighSlide 为博客添加HighSlide弹窗效果与相册功能 1.4.7 查看 HighSlide.zip Links 友情链接插件 1.1.2 查看 Links.zip LoveKKComment Typecho 评论通知、找回密码插件 1.0.5 查看 LoveKKComment.zip Parsedown Plugin 替换markdown解析源 1.0 无 Parsedown.zip Pio 一个简易的 Live2D 插件 2.4 查看 Pio.zip 权限狗 修改注册时默认用户组，贡献者可直接发布文章无需审核,前台注册支持用户输入密码,支持模板开发者设置前台注册后的跳转地址，设置前台文章发布后的跳转地址 1.3.0 查看 Rdog.zip Sitemap Google Sitemap 生成器 1.0.1 无 Sitemap.zip SmartSpam 智能评论过滤器，让机器人彻底远离你！ 2.6.0 查看 SmartSpam.zip TeStore 通过读取html表格实现插件仓库的下载、安装及卸载等功能 1.1.2 查看 TeStore.zip WTS 模仿ACFUN通知条公告 1.0.0 查看 WTS.zip WikimoeBangumi Bangumi追番表 1.0.0 查看 bangumi_plugin.zip notice 一款消息通知插件，判断来路地址输出欢迎消息。 0.3 查看 notice.zip Login Designer 博客登录/注册页面美化插件，提供多种美化样式 1.3.0 查看 LoginDesigner.zip 主题 名称 最新版本 类型 文档 Cuckoo v1.0.4Beta 前台 查看 Fresh v3.0 后台 查看 Freshv3.0食用方法 下载到本地 将Fresh重命名为admin，覆盖原admin文件夹 将此时的admin/菜单文件中的Menu.php**（好像文件名是Meun.php，重命名）**替换根目录的var/Widget/Menu.php即可 ","link":"http://diego3893.github.io/post/an-li-typecho-cha-jian/"},{"title":"安利一波PY植物大战僵尸","content":"用不一样的方式来嗨皮（高逼格） 先放图 文件下载： 各位可以先去Star一波哦PythonPlantsVsZombies PythonPlantsVsZombies.zip python安装 看这篇博客 准备嗨皮 管理员命令行运行pip install pygame 转至PythonPlantsVsZombies文件夹（放在桌面） 命令行操作（此时路径为C:\\Users\\UserName) 输入：cd desktop/PythonPlantsVsZombies 此时路径为：C:\\Users\\UserName\\Desktop\\PythonPlantsVsZombies&gt; 执行python main.py JUST ENJOY！ ","link":"http://diego3893.github.io/post/an-li-yi-bo-py-zhi-wu-da-zhan-jiang-shi/"},{"title":"Github加速法","content":"github几kb的网速真的烦人，那么我们来搞一搞事情！ hosts加速 此文件在C:\\Windows\\System32\\drivers\\etc 记事本打开，添加以下： 192.30.253.112 github.com 192.30.253.113 github.com 151.101.184.133 assets-cdn.github.com 151.101.185.194 github.global.ssl.fastly.net 保存好 cmd输入ipconfig /flushdns 说白了就是忽略DNS直接访问 下载加速 感谢马云（雾）码云gitee 1注册账号 此项略过 2添加仓库 从URL导入 把地址复制进去即可 3同步仓库 点一下就OK啦 ","link":"http://diego3893.github.io/post/github-jia-su-fa/"},{"title":"Python3.7安装笔记","content":"安装包下载：python-3.7.7-amd64.zip 安装教程参照这个 pip加速 在C:/Users/UserName下新建文件夹pip 在C:/Users/UserName/pip下新建pip.ini 写入内容： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple 即新建一个txt，复制上述内容到txt文档中，另存为pip.ini 注：pip安装请一定使用管理员权限 具体方式： 右键单击左下角win图标，点击命令提示符（管理员） ","link":"http://diego3893.github.io/post/python37-an-zhuang-bi-ji/"},{"title":"[转载]HighSlide1.4.7使用方法","content":"本文转自：羽中大佬https://www.yzmb.me/archives/net/highslide-for-typecho 插件下载 点击查看 先放链接：`http://blog.diego.plus:2000/usr/uploads/2020/04/481870875.zip` 使用指南 弹窗实现 &lt;a href=&quot;https://yzmb-1252422232.file.myqcloud.com/usr/uploads/highslide/young_life.jpg&quot; title=&quot;小图链大图&quot;&gt; &lt;img src=&quot;https://yzmb-1252422232.file.myqcloud.com/usr/uploads/highslide/young_life_s.jpg&quot; alt=&quot;图片链接&quot; /&gt; &lt;/a&gt; &lt;a href=&quot;https://yzmb-1252422232.file.myqcloud.com/usr/uploads/highslide/young_life.jpg&quot; title=&quot;文字链大图&quot;&gt; 文字链接 &lt;/a&gt; 附件图片裁剪 相册*（手动高光）* 插件启用后会在数据库新增一行typecho_gallery并在管理菜单内添加独立面板入口如下： 通过面板右上方的预览区域可以方便地进行图片上传与缩略图截取操作，然后填写各项信息录入左侧列表。其中图片名称用于后台标识，描述则可以在前台显示。录入完毕后即可在页面内容里写入[GALLERY-相册组数字]发布显示。默认每个相册组第一张图片为封面，可通过拖拽调整排序。多个相册支持[GALLERY-数字,数字,...](半角逗号隔开)形式联合输出，方便横排显示和加速解析。 我的相册老司机专用(doge) html弹窗标签 &lt;hs id=&quot;pop1&quot; text=&quot;点我看MM&quot; title=&quot;窗中窗效果演示&quot; width=&quot;500&quot; height=&quot;310&quot;&gt; &lt;div style=&quot;text-align:center;&quot;&gt; &lt;span style=&quot;color:#666;font-weight:bold;&quot;&gt;点击下图换MM&lt;/span&gt; &lt;a href=&quot;https://yzmb-1252422232.file.myqcloud.com/usr/uploads/highslide/mm2.gif&quot; title=&quot;&quot;&gt; &lt;img src=&quot;https://yzmb-1252422232.file.myqcloud.com/usr/uploads/highslide/mm1.gif&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;/hs&gt; &lt;hs text=&quot;点我看演示&quot; ajax=&quot;http://www.yzmb.me/links.html#comments&quot; title=&quot;“LINK有情”页面评论区&quot; height=&quot;600&quot;&gt; ajax模式调用目标页面做弹窗内容，故此处文字不会显示。 &lt;/hs&gt; ","link":"http://diego3893.github.io/post/zhuan-zai-highslide147-shi-yong-fang-fa/"},{"title":"设置网页的站点图标","content":"压缩图片 进入这个 上传图片，它会把图片压缩为16*16和gif的两张，下载压缩包 修改网页 静态图标 上传favicon.ico至网站根目录 在&lt;head&gt;和&lt;/head&gt;之间加上如下 &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; &gt; 动态图标 上传favicon.ico和animated_favicon1.gif至网站根目录 在&lt;head&gt;和&lt;/head&gt;之间加上如下 &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; &gt; &lt;link rel=&quot;icon&quot; type=&quot;image/gif&quot; href=&quot;animated_favicon1.gif&quot; &gt; ","link":"http://diego3893.github.io/post/she-zhi-wang-ye-de-zhan-dian-tu-biao/"},{"title":"第二次打卡：2020年4月10日","content":"此次打卡实为搬砖 蒟蒻并没有学懂这个😭 离散化模版 /* 作者：路讯先生 类型：模板 博客链接：https://lxxs.xyz/ */ #include&lt;bits/stdc++.h&gt; #define N 300010 #define For(i,l,r) for(int i = l;i&lt;=r;i++) using namespace std; int all[N],allsi;int q[N]; int n,m; struct node{ int fir; int sec; }; node add[N],que[N];int addsi,quesi; int main(){ cin&gt;&gt;n&gt;&gt;m; For(i,1,n){//存储操作并把点保存。 int x,c; cin&gt;&gt;x&gt;&gt;c; add[++addsi].fir=x;add[addsi].sec=c; all[++allsi]=x; } For(i,1,m){//存储查询的点 int l,r; cin&gt;&gt;l&gt;&gt;r; que[++quesi].fir=l;que[quesi].sec=r; all[++allsi]=l;all[++allsi]=r; } sort(all+1,all+allsi+1);//排序 allsi=unique(all+1,all+allsi+1)-(all+1);//去重并获取最后一个数的下标 For(i,1,n){//进行操作。【对离散化后的数组】 int x = lower_bound(all+1,all+allsi+1,add[i].fir)-all; q[x]+=add[i].sec; } For(i,1,allsi){//计算前缀和 q[i]+=q[i-1]; } For(i,1,m){//查找离散化后的位置，输出答案 int l,r; l = lower_bound(all+1,all+allsi+1,que[i].fir)-all; r = lower_bound(all+1,all+allsi+1,que[i].sec)-all; cout&lt;&lt;q[r]-q[l-1]&lt;&lt;endl; } } 区间合并 /* 作者：路讯先生 类型：模板 博客链接：https://lxxs.xyz/ */ int merge(PII segs[N],int begin,int end) { PII res[N];//答案数组 int cnt=0;//用于计算区间 sort(segs+begin,segs+end);//排序，先按照开始区间，再按照结束区间PII刚好符合这个特性 int st = -2e9, ed = -2e9;//开始结束都要无穷大和无穷小 For(i,begin,end)//遍历原区间数组 if (ed &lt; seg.first)//判断师傅合并 { if (st != -2e9) res[++cnt]=({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); if (st != -2e9) res[++cnt]({st, ed}); strcpy(res,segs,sizeof res); return cnt; } ","link":"http://diego3893.github.io/post/di-er-ci-da-qia-2020-nian-4-yue-10-ri/"},{"title":"第一次打卡----2020.03.30","content":"第一次打卡哦：C++基础 模版代码: #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; using namespace std; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q; struct node{ int a, b; int operator + (const node &amp;t) const {return b+t.a;} }x, y; bool cmp(const int&amp;, const int&amp;); void qsort(int, int); int q1[8] = {9,1,2,0,8,19,99,80}; int q2[10] = {0,9,1,2,0,8,19,99,80}; int q3[8] = {9,1,2,0,8,19,99,80}; int main() { x = {1, 2}, y = {9, 8}; //STL快排 sort(q1, q1+8, cmp); for(int i=0; i&lt;8; ++i) printf(&quot;%d &quot;, q1[i]); printf(&quot;\\n&quot;); //手写快排 qsort(1, 8); for(int i=1; i&lt;=8; ++i) printf(&quot;%d &quot;, q2[i]); printf(&quot;\\n&quot;); //重载运算符 int t = x+y; printf(&quot;%d\\n&quot;, t); //优先队列 for(int i=0; i&lt;8; ++i) { int tmp = q3[i]; q.push(tmp); } while(q.size() &gt; 0) { printf(&quot;%d &quot;, q.top()); q.pop(); } return 0; } bool cmp(const int &amp;a, const int &amp;b) { return a&lt;b; } void qsort(int left, int right) { if(left &gt; right) return; int tmp; tmp = q2[left]; int i=left, j=right; while(i != j) { while(q2[j]&gt;=tmp &amp;&amp; i&lt;j) --j; while(q2[i]&lt;=tmp &amp;&amp; i&lt;j) ++i; if(i &lt; j) swap(q2[i], q2[j]); } q2[left] = q2[i]; q2[i] = tmp; qsort(left, i-1); qsort(i+1, right); return; } emmm，结构体赋值用的C++11语法，懒一下哈~ 巨佬模版 /* 作者：路讯先生 类型：模板 博客链接：https://lxxs.xyz/ */ #include&lt;bits/stdc++.h&gt; #define N 10000010 #define For(i,l,r) for(int i = l;i&lt;=r;i++) #define INF 0x3f3f3f3f #define PII pair&lt;int,int&gt; #define LL long long #define ULL unsigned long long #define mod 1e9+7 #define it ::iterator using namespace std; struct node{ int a,b; node operator +(const node f)const{ node tmp; tmp.a=a+f.a; tmp.b=b+f.b; return tmp; } }; int main(){ queue&lt;int&gt; a; a.pop();a.push();a.size();a.empty();a.back();a.front(); priocity_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;b; b.push();b.top();b.top(); string s; s.size();s.length();s.clear();s.substr(); PII c; c.first;c.second; stack&lt;int&gt; d; d.push();d.pop();d.top();d.empty();d.size(); map&lt;int,int&gt;e; e.insert({,});e.erase();e.find;e[]; int f=(LL)f*mod%mod; freopen(&quot;x.in&quot;,&quot;r&quot;,stdin); freopen(&quot;x.out&quot;,&quot;w&quot;,stdout); ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); memset(ss,0x3f,sizeof ss); vector&lt;int&gt; q; for(vector&lt;int&gt;it i=q.begin();i!=q.end();i++) l = lower_bound(all+1,all+allsi+1,que[i].fir)-all; allsi=unique(all+1,all+allsi+1)-(all+1);//去重并获取最后一个数的下标 swap(a,b); sort(a+1,a+n+1); reverse(a+1,a+n+1); next_permutation(a+1,a+n+1); prev_permutation(a+1,a+n+1); } 新增：栈与队列STL 栈 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;iostream&gt; using namespace std; stack&lt;char&gt;s; void sta(); void que(); int main() { sta(); return 0; } void sta() { char t; int n; scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) { cin &gt;&gt; t; if(t == '(') s.push(t); if(t == ')') if(!s.empty()) s.pop(); else { printf(&quot;No\\n&quot;); return; } } if(!s.empty()) printf(&quot;No\\n&quot;); else printf(&quot;Yes\\n&quot;); return; } 队列 #include&lt;cstdio&gt; #include&lt;queue&gt; using namespace std; queue&lt;int&gt;m; queue&lt;int&gt;w; int main() { int flag = 0, x, y; int male, female, number; scanf(&quot;%d%d%d&quot;, &amp;male, &amp;female, &amp;number); while(flag != male) m.push(++flag); flag = 0; while(flag != female) w.push(++flag); for(int i=0; i&lt;number; ++i) { printf(&quot;%d %d\\n&quot;, m.front(), w.front()); x = m.front(); y = w.front(); m.pop(); w.pop(); m.push(x); w.push(y); } return 0; } ","link":"http://diego3893.github.io/post/di-yi-ci-da-qia-20200330/"},{"title":"Typecho和FusionApp制作属于自己的BlogApp","content":"先给自己的APP打个advertisement：前往下载 我改主题搞了几个小时，插件也找了半天，你难道想白嫖？？？ 实际上你真的可以白嫖~~（手动滑稽）~~ 可以先参考这个大佬的文章 FusionApp下载链接在里面 Web端配置 主题及插件：前往下载 插件配置此处不讲，有一些不用配，有问题请评论或邮箱联系：diegozcx@foxmail.com 内容修改在page_索引.php和page_更多.php中，我已经打上注释了，在控制台外观配置中也可以添加内容 矢量图可以在这里找一找 新建独立页面：模板为page_索引/更多/bangumi.php FA配置 新建一个模版底栏模板 底栏项目为：首页，索引，更多————首页为你的博客网址，索引为索引独立页面的网址，更多为更多独立页面的网址 打开侧滑栏，新建项目：追番，关于————点击事件设置：右上角加好点开有一个加载网页，填写独立页面网址即可 在属性的属性设置中顶栏标题自己设置一下 大致就这样了，预览一下没问题点击右上角的三个点点，点击打包安装即可 写在最后 如果您觉得还不错或者有问题，评论区说一声哦 要打赏的话，万分感谢哦，逃~ ","link":"http://diego3893.github.io/post/typecho-he-fusionapp-zhi-zuo-shu-yu-zi-ji-de-blogapp/"},{"title":"高精度","content":"原理：竖式计算 注意：倒序存储 加/减法 模版（加，减差不多） #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; struct sd{ int d[300], len; }a, b; sd read_num(); sd Plus(sd, sd); void print(sd); int main() { a = read_num(), b = read_num(); a = Plus(a, b); print(a); return 0; } sd read_num() { sd x; memset(x.d, 0, sizeof(x.d)); char s[300]; cin &gt;&gt; s; x.len = strlen(s); int k = 0; for(int i=x.len-1; i&gt;=0; --i) x.d[k++] = s[i]-'0'; return x; } sd Plus(sd x, sd y) { sd t; memset(t.d, 0, sizeof(t.d)); int len = x.len&gt;y.len?x.len:y.len; //printf(&quot;%d\\n&quot;, len); for(int i=0; i&lt;len; ++i) { //printf(&quot;%d %d\\n&quot;, x.d[i], y.d[i]); t.d[i] += x.d[i]+y.d[i]; //printf(&quot;%d &quot;, (int)t.d[i]); t.d[i+1] = t.d[i]/10; //printf(&quot;%d &quot;, (int)t.d[i+1]); t.d[i] = t.d[i]%10; //printf(&quot;%d\\n&quot;, (int)t.d[i]); } if(t.d[len] &gt; 0) t.len = len+1; else t.len = len; return t; } void print(sd x) { for(int i=x.len-1; i&gt;=0; --i) printf(&quot;%d&quot;, (int)x.d[i]); return; } 乘法 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; struct sd{ int d[300], len; }a, b; sd read_num(); sd Mult(sd, sd); void print(sd); int main() { a = read_num(), b = read_num(); a = Mult(a, b); print(a); return 0; } sd read_num() { sd x; memset(x.d, 0, sizeof(x.d)); char s[300]; cin &gt;&gt; s; x.len = strlen(s); int k = 0; for(int i=x.len-1; i&gt;=0; --i) x.d[k++] = s[i]-'0'; return x; } sd Mult(sd x, sd y) { sd t; memset(t.d, 0, sizeof(t.d)); //int len = x.len&gt;y.len?x.len:y.len; //printf(&quot;%d\\n&quot;, len); for(int i=0; i&lt;x.len; ++i) { int temp = 0; for(int j=0; j&lt;y.len; ++j) { t.d[i+j] = x.d[i]*y.d[j]+temp+t.d[i+j]; temp = t.d[i+j]/10; t.d[i+j] %= 10; } t.d[i+y.len] = temp; } t.len = x.len+y.len; return t; } void print(sd x) { while(x.d[x.len-1]==0 &amp;&amp; x.len&gt;0) --x.len; for(int i=x.len-1; i&gt;=0; --i) printf(&quot;%d&quot;, (int)x.d[i]); return; } #除法 高精除以低精 高精除以高精 ","link":"http://diego3893.github.io/post/gao-jing-du/"},{"title":"哈希算法","content":"对数据进行处理，方便匹配 整数 原理 用hash操作，将数作为数组下标存储 照搬原话：大数化小，小数化了（不变） hash冲突：1.线性 2.链式结构 线性伪代码： int k = x/m; int p = flag[k]; while(1) { if(hash[p]==x) { printf(&quot;%d&quot;,hash[p]); break; } if(hash[p]==0) { hash[p]=x; break; } if(hash[p]!=x&amp;&amp;hash[p]!=0) ++p; } 字符串（重点） 原理 HASHC=(C1∗bm−1+C2∗bm−2+……+Cm∗b0)modhHASH_C = (C_1*b^{m-1}+C_2*b^{m-2}+ …… +C_m*b^0) mod hHASHC​=(C1​∗bm−1+C2​∗bm−2+……+Cm​∗b0)modh b，h互质 字符处理：映射: A-&gt;1,B-&gt;2,……,a-&gt;27,b-&gt;28 匹配一段字符串：HASHD=HASHC,k+lenD−HASHC,k∗blenDHASH_D = HASH_{C,k+lenD}-HASH_{C,k}*b^{lenD}HASHD​=HASHC,k+lenD​−HASHC,k​∗blenD HASHC,kHASH_{C,k}HASHC,k​表示字符串C前k个字符的哈希值 乘以lenD原因如图，自行理解： 同余(当 blenb^{len}blen过大时) (a+b) mod c = (a mod c + b mod c) mod c ab mod c = (a mod c * b mod c) mod c 模版 求T组大写字符串中s1在s2中出现了几次： #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; typedef unsigned long long ULL; ULL power[1000002]; ULL T, b = 2; char s1[10002], s2[1000002]; ULL sum[1000002], s; int main() { power[0] = 1; for(int i=1; i&lt;1000000; ++i) power[i] = power[i-1]*b; scanf(&quot;%lld&quot;, &amp;T); while(T--) { scanf(&quot;%s%s&quot;, s1+1, s2+1); int n = strlen(s1+1), m = strlen(s2+1); sum[0] = 0; for(int i=1; i&lt;=m; ++i) sum[i] = sum[i-1]*b+(ULL)(s2[i]-'A'+1); s = 0; for(int i=1; i&lt;=n; ++i) s = s*b+(ULL)(s1[i]-'A'+1); int ans = 0; for(int i=0; i&lt;=m-n; ++i) if(s==sum[i+n]-sum[i]*power[n]) ++ans; printf(&quot;%d\\n&quot;, ans); } return 0; } ","link":"http://diego3893.github.io/post/ha-xi-suan-fa/"},{"title":"免费CDN","content":"GITHUB：https://cdn.jsdelivr.net/gh/user/repo@version/file 详参：官网 ","link":"http://diego3893.github.io/post/mian-fei-cdn/"},{"title":"Valine评论设置邮箱提醒（转）","content":"链接：https://blog.csdn.net/cungudafa/article/details/104497664 转自：CSDN，cungudafa 如有侵权，邮箱联系我：3013006997@qq.com ","link":"http://diego3893.github.io/post/valine-ping-lun-she-zhi-you-xiang-ti-xing-zhuan/"},{"title":"树状数组","content":"这是比较让我这个蒟蒻绝望的东西（以后可能一直这样） 原理 形态如图 Cx=∑i=x−2k+1x−2k+xAiC_x = \\sum_{i=x-2^k+1}^{x-2^k+x}A_iCx​=∑i=x−2k+1x−2k+x​Ai​ 2k2^k2k为区间最小二次幂，即lowbit(x) e.g. (8)10=(1000)2(8)_{10} = (1000)_2(8)10​=(1000)2​，lowbit(8)=23lowbit(8) = 2^3lowbit(8)=23 e.g. (10)10=(1010)2(10)_{10} = (1010)_2(10)10​=(1010)2​，lowbit(10)=21lowbit(10) = 2^1lowbit(10)=21 以区间的方式存储，可以方便的求和、维护（前缀和等） lowbit的位运算 因为是求最小二次幂 所以是(~x+1)&amp;x，即(-x)&amp;x 核心代码 //维护|构建 void build(int x) { while(x &lt;= N) { c[x] += a[x]; x += lowbit(x); } } //求和 int sum(int x) { int res = 0; while(x &gt; 0) { res += c[x]; x -= lowbit(x); } return res; } //求最小二次幂 int lowbit(int x) { return (-x) &amp; x; } 模版 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #define Maxn 15000+10 #define Maxc 32000+10 using namespace std; struct node{ int x, y; }p[Maxn]; int n, m = 32001; int c[Maxc], ans[Maxc]; int lowbit(int); void build(int, int); int sum(int); int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d&quot;, &amp;p[i].x, &amp;p[i].y); for(int i=1; i&lt;=n; ++i) { int u = p[i].x+1; //树状数组无法维护下标0 int w = sum(u); build(u, 1); ++ans[w]; } for(int i=0; i&lt;n; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0; } int lowbit(int x) { return (-x) &amp; x; } void build(int x, int y) { while(x &lt;= m) //x范围不定，直接计算到最大 { c[x] += y; x += lowbit(x); } } int sum(int x) { int res = 0; while(x &gt; 0) { res += c[x]; x -= lowbit(x); } return res; } 题目传送门 ","link":"http://diego3893.github.io/post/shu-zhuang-shu-zu/"},{"title":"Gridea静态博客使用CNAME以及相关配置","content":"0 准备工作 注册域名使用腾讯云 加速以及https配置使用cloudflare 1 注册域名 1.1 注册 进入腾讯云注册域名 购买过程不说，非常简单 支付完成后，进入管理页面 如果服务状态显示未实名认证，请立即实名认证 认证完成后，服务状态会显示正常 备案不管它 1.2 解析 进入解析页面 添加两条解析记录，配置如图 （记录值为username.github.io，即博客地址） 1.3 CNAME绑定 1.3.1 github绑定 在custom domain中填入域名 1.3.2 Gridea绑定 2 在cloudflare中添加域名并启用CDN 看这篇教程 注：腾讯云修改DNS如下 3 在cloudflare中配置https 3.1 添加一条A记录 在DNS目录下 确保是这两条（IPv4获取方式自行百度，cmd使用ping） 3.2 打开https 设置为Flexible 打开always use https 3.3 设置Page Rules 网址分别为http://yourdomain/*和http://yourdomain/ 如果一切正常的话，应该会有以下： 有问题请在下方评论或发邮件询问我 3013006997@qq.com ","link":"http://diego3893.github.io/post/gridea-jing-tai-bo-ke-shi-yong-cname-yi-ji-xiang-guan-pei-zhi/"},{"title":"图的存储","content":"邻接矩阵 简单，不讲 g[i][j]表示从i到j的边权 邻接表（数组） u, v, w记录边的信息 first初始化-1，表示没有边 first[u[i]]保存u[i]的第一条边编号，next[i]存储编号为i的边的下一条边的编号 模版 无向图 #include&lt;cstdio&gt; #define N 100 using namespace std; int main() { int m; scanf(&quot;%d&quot;, &amp;m); int first[N*2], next[N*2]; for(int i=0; i&lt;N; ++i) first[i] = -1; int u[N*2], v[N*2], w[N*2]; for(int i=1; i&lt;=m*2; i+=2) { scanf(&quot;%d%d%d&quot;, &amp;u[i], &amp;v[i], &amp;w[i]); u[i+1] = v[i]; v[i+1] = u[i]; w[i+1] = w[i]; next[i] = first[u[i]]; first[u[i]] = i; next[i+1] = first[u[i+1]]; first[u[i+1]] = i+1; } int k; for(int i=1; i&lt;=m*2; ++i) { k = first[i]; while(k != -1) { printf(&quot;%d %d %d\\n&quot;, u[k], v[k], w[k]); k = next[k]; } } return 0; } 有向图 #include&lt;cstdio&gt; using namespace std; int main() { int m, n; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int first[n+1], next[m+1]; for(int i=0; i&lt;N; ++i) first[i] = -1; int u[m+1], v[m+1], w[m+1]; for(int i=1; i&lt;=m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u[i], &amp;v[i], &amp;w[i]); next[i] = first[u[i]]; first[u[i]] = i; } int k; for(int i=1; i&lt;=n; ++i) { k = first[i]; while(k != -1) { printf(&quot;%d %d %d\\n&quot;, u[k], v[k], w[k]); k = next[k]; } } return 0; } ","link":"http://diego3893.github.io/post/tu-de-cun-chu/"},{"title":"最短路径","content":"Floyd-Warshall 原理 分别枚举起始点i，中转点k，目标点j 如果e[i][k]+e[k][j] &lt; e[i][j] 更新e[i][j]的值 中转点枚举在最外层 模版 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define N 100 #define INF 0x7fffff using namespace std; int main() { int g[N][N] = {}; for(int i=0; i&lt;=N; ++i) for(int j=0; j&lt;=N; ++j) if(i != j) g[i][j] = INF; else g[i][j] = 0; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int u, v, w; for(int i=0; i&lt;m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); g[u][v] = w; } for(int k=1; k&lt;=n; ++k) for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=n; ++j) g[i][j] = min(g[i][j], g[i][k]+g[k][j]); printf(&quot;%d&quot;, g[1][n]); return 0; } Dijkstra 原理 假设起点为1号节点 初始化1号节点的出边权值至dis数组（估计值） 找当前dis中最小边权（确定值）（假设为2号节点） 以2号节点的出边边权更新dis数组，若e[2][i]+dis[2] &lt; dis[i]，就更新dis[i] 以此类推，进行松弛 每次找离源点最近的点，然后依次进行扩展 用book数组进行标记是否使用 模版 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define N 100 #define INF 0x7ffff using namespace std; int main() { int e[N][N], dis[N], book[N]; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=n; ++j) if(i == j) e[i][j] = 0; else e[i][j] = INF; int u, v, w; for(int i=1; i&lt;=m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); e[u][v] = w; } for(int i=1; i&lt;=n; ++i) dis[i] = e[1][i]; memset(book, 0, sizeof(book)); book[1] = 1; int minn = INF, k; for(int i=1; i&lt;=n; ++i) { minn = INF; for(int j=1; j&lt;=n; ++j) if(!book[j] &amp;&amp; dis[j]&lt;minn) { minn = dis[j]; k = j; } book[k] = 1; for(int j=1; j&lt;=n; ++j) if(e[k][j]&lt;INF) dis[j] = min(dis[j], dis[k]+e[k][j]); } for(int i=1; i&lt;=n; ++i) printf(&quot;%d &quot;, dis[i]); return 0; } Bellman-Ford 原理 进行n-1轮松弛（详见Dijkstra） 没啥好说的 模版 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define N 100 #define INF 0x7ffff using namespace std; int main() { int dis[N], n, m, u[N], v[N], w[N]; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=m; ++i) scanf(&quot;%d%d%d&quot;, &amp;u[i], &amp;v[i], &amp;w[i]); for(int i=1; i&lt;=n; ++i) dis[i] = INF; dis[1] = 0; int check = 0; //检查dis是否改变 for(int i=1; i&lt;=n-1; ++i) { check = 0; for(int j=1; j&lt;=n; ++j) if(dis[v[j]] &gt; dis[u[j]]+w[j]) { dis[v[j]] = dis[u[j]]+w[j]; check = 1; } if(!check) //优化 break; } int flag = 0; for(int i=1; i&lt;=m; ++i) if(dis[v[i]] &gt; dis[u[i]]+w[i]) flag = 1; if(flag) printf(&quot;有负权回路&quot;); else for(int i=1; i&lt;=n; ++i) printf(&quot;%d &quot;, dis[i]); return 0; } SPFA 原理 用队列优化的Bellman-Ford 思想差不多（Bellman-Ford+BFS） 不用像BFS一样打标记（敲黑板） 不会邻接表的参考我的这篇博文 模版（邻接表） #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define N 100 #define INF 0x7ffff using namespace std; int main() { int n, m; int u[N], v[N], w[N]; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int first[n+1], next[m+1]; int dis[N] = {}, book[N] = {}, que[N] = {}, head = 1, tail = 1; for(int i=1; i&lt;=n; ++i) dis[i] = INF; dis[1] = 0; for(int i=1; i&lt;=n; ++i) first[i] = -1; for(int i=1; i&lt;=m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u[i], &amp;v[i], &amp;w[i]); next[i] = first[u[i]]; first[u[i]] = i; } que[tail++] = 1; book[1] = 1; int k; while(head &lt; tail) { k = first[que[head]]; while(k != -1) { if(dis[v[k]] &gt; dis[u[k]]+w[k]) { dis[v[k]] = dis[u[k]]+w[k]; if(book[v[k]] == 0) { que[tail++] = v[k]; book[v[k]] = 1; } } k = next[k]; } book[que[head]] = 0; head++; } for(int i=1; i&lt;=n; ++i) printf(&quot;%d &quot;, dis[i]); return 0; } 算法比较 Floyd-Warshall Dijkstra Bellman-Ford SPFA 空间复杂度 O(N2N^2N2) O(M) O(M) O(M) 时间复杂度 O(N3N^3N3) O((M+N)logN) O(NM) 最坏也是O(NM) 适用情况 稠密图，与顶点关系密切 稠密图，与顶点关系密切 稀疏图，与边关系密切 稀疏图，与边关系密切 负权 Y N Y Y 负权边 Y N Y Y 负权回路判定 N N Y Y ","link":"http://diego3893.github.io/post/zui-duan-lu-jing/"},{"title":"STL合集","content":" 也可以参考这个 ","link":"http://diego3893.github.io/post/stl-he-ji/"},{"title":"c++快读（数字）","content":"代码 inline int fread() { int x=0,f=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){ if(ch=='-') f=-1; ch=getchar(); } while(ch&gt;='0'&amp;&amp;ch&lt;='9'){ x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); } return x*f; } 原理 getchar()比scanf()快 f判断正负 重点在x = (x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48) x&lt;&lt;1= x∗2x*2x∗2， x&lt;&lt;3= x∗2∗2∗2x*2*2*2x∗2∗2∗2 (x&lt;&lt;1)+(x&lt;&lt;3) = x*10 ch^48=ch-'0' ","link":"http://diego3893.github.io/post/ckuai-du-shu-zi/"},{"title":"c++版WIN XP ??!","content":"转载自某位B站大神，如有侵权请联系邮箱：3013006997@qq.com 效果图： 原视频以及源码地址 video source 代码 /*--------------------------------------------------------- 程序： 模拟笔记本电脑 （纯C语言，可直接编译器运行） 作者： 0.0 说明： 1.这个程序本意在模拟电脑的基本功能，重在实现键盘的输入与键盘的控制，模拟开机，输密，打开软件，关闭电脑，所以其他功能暂没开发，不用太失望。 2.不同的编码会有不同的长度显示，但运行出来的效果都是一样的 3.代码规范不到位，见谅。 4.大一上写的，一般写小游戏练手，也琢磨到一些特殊的处理方法，所以对一些功能处理上有一些难理解的地方。 5.emmm，没啥了 ---------------------------------------------------------*/ #include &lt;conio.h&gt; //用于getch（） #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;windows.h&gt; char start[20][300] = { //图形界面 {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /~/~/ /&quot;}, {&quot; \\\\ /~/~/ /&quot;}, {&quot; \\\\ Microsotf@ ~ ~ __ XP /&quot;}, {&quot; \\\\ \\\\ /\\\\ / - _ _| _ _ _ /_ /&quot;}, {&quot; \\\\ \\\\/ \\\\/ | | | |_| |_| \\\\/\\\\/ __/ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ _____________________ /&quot;}, {&quot; \\\\ │ │ /&quot;}, {&quot; \\\\ └────────────────────┘ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ Copyright ΘMicrosoft Corporation Microsoft* /&quot;}, {&quot; \\\\ __________________________________________________________________________________________/&quot;}}; char password[20][300] = { {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ ------------------------------------------------------------------------------------------------------------------ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ | /&quot;}, {&quot; \\\\ | /&quot;}, {&quot; \\\\ | ┌───────────────────────────────────────────── /&quot;}, {&quot; \\\\ /~/~/ | │┌─────┐ Administrator /&quot;}, {&quot; \\\\ /~/~/ __XP | ││ [] │ 输入密码 /&quot;}, {&quot; \\\\ \\\\ /\\\\ / - _ _| _ ~ ~ /_ | │└─────┘ 【| 】ck[→] /&quot;}, {&quot; \\\\ \\\\/ \\\\/ | | | |_| |_| \\\\/\\\\/ __/ | └─────────────────────────────────────── /&quot;}, {&quot; \\\\ | /&quot;}, {&quot; \\\\ 要开始，请单击您的用户名 | /&quot;}, {&quot; \\\\ | /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ ---------------------------------------------------------------------------------------- /&quot;}, {&quot; \\\\ __________________________________________________________________________________________/&quot;}}; char desktop[20][300] = { {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;}, {&quot; \\\\ ───── ───── ───── ┌────┐ ┌────┐ /&quot;}, {&quot; \\\\ \\\\ [] \\\\ \\\\ \\\\ \\\\ \\\\ │ │ │ing │ /&quot;}, {&quot; \\\\ ───── ───── ───── └────┘ └────┘ /&quot;}, {&quot; \\\\ 小游戏 垃圾桶 计算器 相关 待开发 /&quot;}, {&quot; \\\\ ───── /&quot;}, {&quot; \\\\ \\\\ \\\\ /&quot;}, {&quot; \\\\ ───── __ --------------- __ __ /&quot;}, {&quot; \\\\ IE浏览器__-- --- __ -------_ -------_------____ /&quot;}, {&quot; \\\\ ____ __--__ -- __ -------_ --- - __ --- __ --------------______ /&quot;}, {&quot; \\\\__ -------_--__ ------- __ ---------- __ ------ __ ------ __ --- __ ---------____ /&quot;}, {&quot; \\\\ -------_---__ ------- _---- __ -------_ ---_ -------_ -_ ----------_ -_---_ -_ ------_ -_ /&quot;}, {&quot; \\\\--__ -- __ ----- __ ------ __ -------_ --- ---- __ -------_ -_ ---------_ -_ ------_ -_ ------ /&quot;}, {&quot; \\\\ -_--__ ------- _---- __ -------_ ------- __ -------_ -- __ -------_ -_ --------__---_ -_ ------/&quot;}, {&quot; \\\\ _____________________________________________________________________________________________ /&quot;}, {&quot; \\\\ 开始 \\\\ qq2010 | | 12:00 /&quot;}, {&quot; \\\\ __________________________________________________________________________________________/&quot;}}; char game_hnt[20][300] = { {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;}, {&quot; \\\\ ┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ └───────────────────────────────────────────────────────────────────────────────────────────┘ /&quot;}, {&quot; \\\\ _____________________________________________________________________________________________ /&quot;}, {&quot; \\\\ 开始 \\\\ qq2010 | 汉诺塔自动演示小游戏 | | 12:08 /&quot;}, {&quot; \\\\ __________________________________________________________________________________________/&quot;}}; char thinking[30][300] = { {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;}, {&quot; \\\\ ┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐ /&quot;}, {&quot; \\\\ 这里是感想： /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ 寒假太颓废了，没劲学习，游戏玩腻，然后开始发呆。安静下来时才有灵感 ，看着笔记本，就想着我也编一个电脑系统吧 /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ 就想把大一上学到的一些东西总着来练练手。。然后发现写电脑系统就是痴人说梦了，我还是写个模拟计算机吧。 /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ 对着自己笔记本的键盘一个一个的还原，然后思考如何体现屏幕，如何移动键盘，如何读取键盘把信息传给我的 /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ 虚拟电脑，如何模拟开机实现基本功能 ，一口气写完真心爽，最后想做互动游戏的，但这斜着的屏幕，emmm /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ 所以最后电脑只能运行汉诺塔，其他功能实现也简单，但还是把时间放在我突然又燃起的学习小火苗上吧/&quot;}, {&quot; \\\\ └───────────────────────────────────────────────────────────────────────────────────────────┘ /&quot;}, {&quot; \\\\ _____________________________________________________________________________________________ /&quot;}, {&quot; \\\\ 开始 \\\\ qq2010 | 感想.txt | | 12:15 /&quot;}, {&quot; \\\\ __________________________________________________________________________________________/&quot;}}; char ending[30][300] = { {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ 正在关机 /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ 请确保你的数据已保存 /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ 0.0 /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ 正在损失数据 /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ 电脑格式化成功 /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ 感谢使用 Xp /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ __________________________________________________________________________________________/&quot;}}; char map[10000][2000] = { {&quot;┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ /&quot;}, {&quot; \\\\ __________________________________________________________________________________________/&quot;}, {&quot; ┌──────────────────────────────────────────────────────────────────────────────────────────┐&quot;}, {&quot; │ ──── │&quot;}, {&quot; │──────────────────────────────────────────────────────────────────────────────────────────│&quot;}, {&quot; │┌─────┐ ┌───┬───┬───┬───┐┌───┬───┬───┬───┐┌───┬───┬───┬───┐┌───┬───┬───┐ │&quot;}, {&quot; ││ Esc │ │ F1│ F2│ F3│ F4││ F5│ F6│ F7│ F8││ F9│F10│F11│F12││Prt│Scr│Pau│ ┌┐ ┌┐ ┌┐ ┌┐ │&quot;}, {&quot; │└─────┘ └───┴───┴───┴───┘└───┴───┴───┴───┘└───┴───┴───┴───┘└───┴───┴───┘ └┘ └┘ └┘ └┘ │&quot;}, {&quot; │┌────┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬─────┐┌───┬───┬───┐┌───┬───┬───┬───┐│&quot;}, {&quot; ││ `~ │ 1!│ 2@│ 3#│ 4$│ 5%│ 6^│ 7&amp;│ 8*│ 9(│ 0)│ -─│ =+│ ←--││Ins│Hom│Pgu││Num│ / │ * │ - ││&quot;}, {&quot; │├────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬────┤├───┼───┼───┤├───┼───┼───┼───┤│&quot;}, {&quot; ││ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │ [{│ ]}│ \\\\| ││Del│End│Pgd││ 7 │ 8 │ 9 │ ││&quot;}, {&quot; │├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴────┤└───┴───┴───┘├───┼───┼───┤ + ││&quot;}, {&quot; ││ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │ ;:│ \\'\\&quot;│ Enter │ │ 4 │ 5 │ 6 │ ││&quot;}, {&quot; │├──────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴───────┤ ┌───┐ ├───┼───┼───┼───┤│&quot;}, {&quot; ││ Shift │ Z │ X │ C │ V │ B │ N │ M │ ,&lt;│ .&gt;│ /?│ Shift │ │ ↑│ │ 1 │ 2 │ 3 │ │││&quot;}, {&quot; │├────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴───┴──┬┴───╪───┬──────┤┌───┼───┼───┐├───┴───┼───┤ │││&quot;}, {&quot; ││ Ctr│ win│ Alt│ ──── │ Alt│ Fn│ Ctrl ││← │ ↓│ →││ 0ins │.de│←┘││&quot;}, {&quot; │└────┴────┴────┴───────────────────────────┴────┴───┴──────┘└───┴───┴───┘└───────┴───┴───┘│&quot;}, {&quot; │ ┌───────────────────────────────┐ │&quot;}, {&quot; │ │ │ │&quot;}, {&quot; │ │ │ │&quot;}, {&quot; │ │───────────────┬───────────────│ │&quot;}, {&quot; │ └───────────────┴───────────────┘ │&quot;}, {&quot; └──────────────────────────────────────────────────────────────────────────────────────────┘&quot;}}; //功能数组 int keyboard[20][30] = { //把键盘看成一个地图让move函数在上面移动返回的数值对应下面的 board_place[120][5]是对应按键的全部信息 {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 104, 104, 104, 104}, {0, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37}, {0, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58}, {0, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 71, 0, 0, 0, 72, 73, 74, 58}, {0, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 86, 86, 0, 87, 0, 88, 89, 90, 91}, {0, 92, 93, 94, 95, 95, 95, 95, 95, 95, 95, 96, 97, 98, 98, 99, 100, 101, 102, 102, 103, 91}, }; int next[9][2] = {{0}, {0}, {0}, {0}, {0}, {-1, 0}, {0, -1}, {1, 0}, {0, 1}}; //给键盘传给虚拟键盘的键盘控制虚拟电脑用 int computer_map[3][8] = {{0, 0, 0, 0, 0}, {0, 1, 2, 3, 4}, {5, 0, 0, 0, 0}}; //对应的移动操作记录 int computer_map_place[6][2] = {{0}, {2, 9}, {2, 19}, {2, 29}, {2, 40}, {6, 12}}; int cx = 1, cy = 1, tcx = computer_map_place[computer_map[cx][cy]][0], tcy = computer_map_place[computer_map[cx][cy]][1], lcx = cx, lcy = cy; int board_place[120][5] = { //这是按键的信息 下标依次对应 -返回值 -按下shift下的返回值2 -键盘字符长度 -字符坐标x -y {0, 0, 0, 0, 0}, //第一项如果是字符那么那就是返回字符 如果是数字1-9那么就是功能按键功能对应如下 {1, 1, 3, 21, 19}, //1-10 {0, 0, 2, 21, 28}, //1 ~ 返回 2 ~删除 3确认 4shift 5上 6左 7下 8又 9开机 {0, 0, 2, 21, 32}, {0, 0, 2, 21, 36}, {0, 0, 2, 21, 40}, {0, 0, 2, 21, 45}, {0, 0, 2, 21, 49}, {0, 0, 2, 21, 53}, {0, 0, 2, 21, 57}, {0, 0, 2, 21, 62}, {0, 0, 3, 21, 65}, // 11 {0, 0, 3, 21, 69}, {0, 0, 3, 21, 73}, {0, 0, 3, 21, 78}, {0, 0, 3, 21, 82}, {0, 0, 3, 21, 86}, {'`', '~', 2, 24, 19}, {'1', '!', 2, 24, 24}, {'2', '@', 2, 24, 28}, {'3', '#', 2, 24, 32}, {'4', '$', 2, 24, 36}, // 21 {'5', '%', 2, 24, 40}, {'6', '^', 2, 24, 44}, {'7', '&amp;', 2, 24, 48}, {'8', '*', 2, 24, 52}, {'9', '(', 2, 24, 56}, {'0', ')', 2, 24, 60}, {'-', '_', 2, 24, 64}, {'=', '+', 2, 24, 68}, {2, 2, 4, 24, 72}, {0, 0, 3, 24, 78}, // 31 {0, 0, 3, 24, 82}, {0, 0, 3, 24, 86}, {0, 0, 3, 24, 91}, {'/', '/', 1, 24, 96}, {'*', '*', 1, 24, 100}, {'-', '-', 1, 24, 104}, {0, 0, 3, 26, 19}, {'q', 'Q', 1, 26, 25}, {'w', 'W', 1, 26, 29}, {'e', 'E', 1, 26, 33}, // 41 {'r', 'R', 1, 26, 37}, {'t', 'T', 1, 26, 41}, {'y', 'Y', 1, 26, 45}, {'u', 'U', 1, 26, 49}, {'i', 'I', 1, 26, 53}, {'o', 'O', 1, 26, 57}, {'p', 'P', 1, 26, 61}, {'[', '{', 2, 26, 65}, {']', '}', 2, 26, 69}, {'\\\\', '|', 2, 26, 73}, // 51 {0, 0, 3, 26, 78}, {0, 0, 3, 26, 82}, {0, 0, 3, 26, 86}, {'7', '7', 1, 26, 92}, {'8', '8', 1, 26, 96}, {'9', '9', 1, 26, 100}, {'+', '+', 1, 27, 104}, {0, 0, 4, 28, 19}, {'a', 'A', 1, 28, 26}, {'s', 'S', 1, 28, 30}, // 61 {'d', 'D', 1, 28, 34}, {'f', 'F', 1, 28, 38}, {'g', 'G', 1, 28, 42}, {'h', 'H', 1, 28, 46}, {'j', 'J', 1, 28, 50}, {'k', 'K', 1, 28, 54}, {'l', 'L', 1, 28, 58}, {';', ':', 2, 28, 62}, {'\\'', '\\&quot;', 2, 28, 66}, {3, 3, 5, 28, 70}, // 71 {'4', '4', 1, 28, 92}, {'5', '5', 1, 28, 96}, {'6', '6', 1, 28, 100}, {4, 4, 5, 30, 19}, {'z', 'Z', 1, 30, 27}, {'x', 'X', 1, 30, 31}, {'c', 'C', 1, 30, 35}, {'v', 'V', 1, 30, 39}, {'b', 'B', 1, 30, 43}, {'n', 'N', 1, 30, 47}, // 81 {'m', 'M', 1, 30, 51}, {',', '&lt;', 2, 30, 55}, {'.', '&gt;', 2, 30, 59}, {'/', '?', 2, 30, 63}, {4, 4, 5, 30, 69}, {5, 5, 2, 30, 83}, {'1', '1', 1, 30, 92}, {'2', '2', 1, 30, 96}, {'3', '3', 1, 30, 100}, {3, 3, 3, 32, 103}, // 91 {0, 0, 3, 32, 19}, {0, 0, 3, 32, 24}, {0, 0, 3, 32, 29}, {' ', ' ', 4, 32, 45}, {0, 0, 3, 32, 62}, {0, 0, 2, 32, 67}, {0, 0, 4, 32, 71}, {6, 6, 2, 32, 78}, {7, 7, 2, 32, 83}, {8, 8, 2, 32, 87}, // 101 {'0', '0', 4, 32, 93}, {'.', '.', 4, 32, 99}, {9, 9, 4, 18, 99}}; // 程序功能变量 int flag = 0, function, if_shift = 0, if_start = 0, if_input_password = 0, if_into_desktop = 0, if_game = 0; //0表示输入无效，1表示是输入电脑键 2表示是功能键， char letter; int x, y, tx, ty, num, lx, ly; char temp[6] = {&quot;=====&quot;}; char put_in_computer[20]; char password_0[20] = {&quot;WHJY&quot;}; // 密码 int put_in_num = 0, if_input = 0, input_x, input_y, input_max; // 汉诺塔游戏变量 int mid_x = 7, mid_y = 60; int len, width, left, mid, right, time; int ttx = 10, tty = 10; char game_map[80][1000]; int game_next[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; //上0下1左2右3； int turn[2][3] = {{0, 3, 1}, //a -&gt; b b -&gt; c a -&gt; c 上右下 {0, 2, 1}}; //b -&gt; a c -&gt; b c -&gt; a 上左下 //实现自动移动的路线储存 void gotoxy(int x, int y) //坐标函数 { HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(handle, pos); } void init_game(int n) { //初始化汉诺塔 time = 50 / n; left = 1, mid = 2 * (n + 1), right = mid + 2 * n + 1; len = 3 * (2 * n + 1); width = n + 1; ttx = mid_x - width / 2; tty = mid_y - len / 2; ; for (int i = 0; i &lt;= width; i++) { for (int j = 0, num = i; j &lt;= len; j++) { if (i == 0 || j == 0 || i == width || j == len) game_map[i][j] = ' '; if ((i &gt; 1 &amp;&amp; i &lt; width) &amp;&amp; (j == mid - 1 || j == right - 1)) game_map[i][j] = '|'; if (num &amp;&amp; (i &gt;= 1 &amp;&amp; i &lt;= width - 1) &amp;&amp; j % 2 != 0 &amp;&amp; j &lt; mid) { game_map[i][j] = -95; game_map[i][j + 1] = -10; //打印 ■ ■占2个字节可以拆开来 num--; } } } //容易出现东西卡顿 for (int i = 0; i &lt;= width; i++) { gotoxy(tty, ttx + i); for (int j = 0; j &lt;= len; j++) printf(&quot;%c&quot;, game_map[i][j]); printf(&quot;\\n&quot;); } } void play(int x, int y) { //显示汉诺塔移动轨迹 int turn_0, n = 0, i, j, k, tx, ty, flag = 0; if ((x == mid &amp;&amp; y == right) || (x == left &amp;&amp; y == mid) || (x == left &amp;&amp; y == right)) turn_0 = 0; //往右 else if ((x == mid &amp;&amp; y == left) || (x == right &amp;&amp; y == left) || (x == right &amp;&amp; y == mid)) turn_0 = 1; //往左 for (i = 1, j = y; i &lt;= width; i++) { //目的地 if (game_map[i][j] != 0) { tx = i - 1; ty = j; break; } } for (i = 1, j = x; i &lt;= width; i++) { //出发点 if (game_map[i][j] != 0) { break; } } while (1) { while ((i != 1 || j != x) &amp;&amp; (i != 1 || j != y) &amp;&amp; (i != tx || j != ty)) { if (turn_0 == 0) for (k = mid - 3; k &gt;= 0; k--) { game_map[i + game_next[turn[turn_0][n]][0]][j + game_next[turn[turn_0][n]][1] + k] = game_map[i][j + k]; game_map[i][j + k] = 0; } else for (k = 0; k &lt; mid - 2; k++) { game_map[i + game_next[turn[turn_0][n]][0]][j + game_next[turn[turn_0][n]][1] + k] = game_map[i][j + k]; game_map[i][j + k] = 0; } gotoxy(j + tty, i + ttx); Sleep(time); for (k = 0; k &lt; mid - 2; k++) { printf(&quot; &quot;); } i = i + game_next[turn[turn_0][n]][0]; j = j + game_next[turn[turn_0][n]][1]; gotoxy(j + tty, i + ttx); Sleep(time); for (k = 0; k &lt; mid - 2; k++) { printf(&quot;%c&quot;, game_map[i][j + k]); } } n++; //改变方向; if (i == tx &amp;&amp; j == ty) return; if (turn_0 == 0) for (k = mid - 3; k &gt;= 0; k--) { game_map[i + game_next[turn[turn_0][n]][0]][j + game_next[turn[turn_0][n]][1] + k] = game_map[i][j + k]; game_map[i][j + k] = 0; } else for (k = 0; k &lt; mid - 2; k++) { game_map[i + game_next[turn[turn_0][n]][0]][j + game_next[turn[turn_0][n]][1] + k] = game_map[i][j + k]; game_map[i][j + k] = 0; } gotoxy(j + tty, i + ttx); for (k = 0; k &lt; mid - 2; k++) { printf(&quot; &quot;); } Sleep(time); i = i + game_next[turn[turn_0][n]][0]; j = j + game_next[turn[turn_0][n]][1]; gotoxy(j + tty, i + ttx); for (k = 0; k &lt; mid - 2; k++) printf(&quot;%c&quot;, game_map[i][j + k]); Sleep(time); } } void move_hnt(int a, int b, int c, char aa, char bb, char cc, int n) { //正常的汉诺塔递归程序 if (n == 1) { //printf(&quot;from %c to %c&quot;,aa,cc); play(a, c); return; } move_hnt(a, c, b, aa, cc, bb, n - 1); /* gotoxy(0,width+1); printf(&quot;from %c to %c&quot;,aa,cc);*/ play(a, c); move_hnt(b, a, c, bb, aa, cc, n - 1); } void init() { //初始化整个程序 printf(&quot;↑ ↓ ← → 空格 进行操作\\n\\n&quot;); printf(&quot;用空格按下电源键即可进行开机\\n\\n&quot;); printf(&quot;xp系统祝你使用愉快~~\\n\\n&quot;); printf(&quot;开机密码WHJY\\n&quot;); printf(&quot;桌面程序只有第一个和相关有用，其他暂未开放\\n&quot;); printf(&quot;汉诺塔程序运行过程中是不能中止的，尽量开6个以下\\n&quot;); //这里是原本写了一个版本，自动变化函数+人工输入函数能中途退出，但改一下整个程序都要改动，就放弃了那个版本 printf(&quot;按任意键继续\\n&quot;); getch(); int i, j, k; system(&quot;color 70&quot;); system(&quot;mode con cols=125 lines=60&quot;); for (int i = 0; i &lt;= 40; i++) { printf(&quot;%s\\n&quot;, map[i]); Sleep(50); } x = 1, y = 20, num = board_place[keyboard[x][y]][2]; tx = board_place[keyboard[x][y]][3]; ty = board_place[keyboard[x][y]][4]; gotoxy(ty, tx); //SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),02); for (i = 0; i &lt; num; i++) { printf(&quot;%c&quot;, temp[i]); } } void init_start() { // 开机 + 动态加载页面 + 打开输入密码权限 gotoxy(0, 0); for (int i = 0; i &lt;= 16; i++) { printf(&quot;%s\\n&quot;, start[i]); Sleep(100); } int l, i, j; for (l = 0; l &lt; 3; l++) { //动态加载 for (i = 53; i &lt;= 71; i = i + 2) { for (j = i - 4; j &lt;= i; j = j + 2) { if (j &gt;= 53 &amp;&amp; j &lt;= 70) { gotoxy(j, 12); printf(&quot;[]&quot;); } Sleep(100); } for (j = i - 4; j &lt;= i; j = j + 2) { if (j &gt;= 53 &amp;&amp; j &lt;= 70) { gotoxy(j, 12); printf(&quot; &quot;); } } } } gotoxy(0, 0); for (int i = 0; i &lt;= 16; i++) { printf(&quot;%s\\n&quot;, password[i]); Sleep(10); } if_input = 1; // 9 77 18个 input_x = 9; input_y = 77; input_max = 18; } void load_desktop() { //加载桌面 if_into_desktop = 1; if_input == 0; gotoxy(0, 0); for (int i = 0; i &lt;= 16; i++) { printf(&quot;%s\\n&quot;, desktop[i]); Sleep(100); } } void end() { //加载关机 （关机做的有点仓促） gotoxy(0, 0); for (int i = 0; i &lt;= 16; i++) { printf(&quot;%s\\n&quot;, ending[i]); Sleep(1000); } gotoxy(0, 0); for (int i = 0; i &lt;= 16; i++) { printf(&quot;%s\\n&quot;, map[i]); Sleep(10); } } void load_more() { //更多信息 gotoxy(0, 0); for (int i = 0; i &lt;= 16; i++) { printf(&quot;%s\\n&quot;, thinking[i]); Sleep(1000); } } void load_game() { //加载汉诺塔程序 if_into_desktop = 0; gotoxy(0, 0); for (int i = 0; i &lt;= 16; i++) { printf(&quot;%s\\n&quot;, game_hnt[i]); Sleep(100); } if_game = 1; gotoxy(mid_y - 16, mid_x); printf(&quot;请输入你要递归的汉诺塔数目_&quot;); input_x = mid_x; input_y = mid_y - 16 + 27; input_max = 1; if_input = 1; } int move() { //控制虚拟键盘的指针移动函数 int i, k; char ch = '\\0', ch1 = '\\0'; while (ch != ' ') { ch = getch(); lx = x, ly = y; if (ch != ' ' &amp;&amp; ch != 'w' &amp;&amp; ch != 's' &amp;&amp; ch != 'a' &amp;&amp; ch != 'd' &amp;&amp; ch != -32) continue; if (ch == -32) { //同时启用wasd 和上下左右键 //如果读取到第一个是-32那么 继续读取一个字符 ch1 = getch(); switch (ch1) { case 72: ch = 'w'; break; case 75: ch = 'a'; break; case 80: ch = 's'; break; case 77: ch = 'd'; break; } } system(&quot;color 70&quot;); gotoxy(0, tx); printf(&quot;%s&quot;, map[tx]); switch (ch) { case 'a': y = y - 1; break; case 'd': y = y + 1; break; case 'w': x = x - 1; break; case 's': x = x + 1; break; case ' ': break; } if (keyboard[x][y] == 0) { x = lx; y = ly; } num = board_place[keyboard[x][y]][2]; tx = board_place[keyboard[x][y]][3]; ty = board_place[keyboard[x][y]][4]; gotoxy(ty, tx); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 57); for (i = 0; i &lt; num; i++) { printf(&quot;%c&quot;, temp[i]); } gotoxy(ty, tx); } system(&quot;color 70&quot;); if (board_place[keyboard[x][y]][0] == 0) return 0; else if (board_place[keyboard[x][y]][0] &gt;= 1 &amp;&amp; board_place[keyboard[x][y]][0] &lt;= 9) { function = board_place[keyboard[x][y]][0]; /*gotoxy(0,41); printf(&quot;%d&quot;,board_place[ keyboard[x][y] ][0]);*/ return 2; } else { letter = if_shift ? board_place[keyboard[x][y]][1] : board_place[keyboard[x][y]][0]; /*gotoxy(0,41); printf(&quot;%c&quot;,board_place[ keyboard[x][y] ][0]);*/ return 1; } } void put_letter_to_computer(char letter) { //把字符传输给电脑屏幕，如果电脑if_input为零就禁止显示 if (if_input == 1 &amp;&amp; put_in_num &lt; input_max) { put_in_computer[put_in_num] = letter; put_in_num++; put_in_computer[put_in_num] = '\\0'; } gotoxy(input_y, input_x); printf(&quot;%s&quot;, put_in_computer); } void put_function_to_computer(int function) { //电脑处理相应共呢 1 ~ 返回 2 ~删除 3确认 4shift 5上 6左 7下 8又 9开机 if (function == 9) { //开机 if (if_start == 0) { init_start(); if_start = 1; } else { end(); if_start = 0; if_into_desktop = 0; } } if (function == 2 &amp;&amp; put_in_num &gt; 0 &amp;&amp; if_input == 1) { //删除字符，但不可越界 put_in_num--; put_in_computer[put_in_num] = '\\0'; gotoxy(input_y, input_x); printf(&quot;%s&quot;, put_in_computer); printf(&quot; &quot;); } if (function == 4) { //切换大小写 if (if_shift) if_shift = 0; else if_shift = 1; } if (function == 3 &amp;&amp; if_input == 1 &amp;&amp; if_game == 0) { //确认对应不同模式下的不同功能 if (strcmp(password_0, put_in_computer) == 0) { load_desktop(); if_input = 0; put_in_num = 0; put_in_computer[put_in_num] = '\\0'; } else { put_in_num = 0; put_in_computer[put_in_num] = '\\0'; gotoxy(input_y, input_x); printf(&quot;密 码 错 误 ！！！&quot;); gotoxy(input_y, input_x); Sleep(1200); printf(&quot; &quot;); gotoxy(input_y, input_x); printf(&quot;|&quot;); } } else if (function == 3 &amp;&amp; if_game == 1 &amp;&amp; put_in_num == 1 &amp;&amp; put_in_computer[0] &gt;= '1' &amp;&amp; put_in_computer[0] &lt;= '9') { gotoxy(mid_y - 16, mid_x); printf(&quot; &quot;); init_game(put_in_computer[0] - '0'); move_hnt(left, mid, right, 'a', 'b', 'c', put_in_computer[0] - '0'); Sleep(2000); for (int i = 0; i &lt;= width; i++) { for (int j = 0; j &lt;= len; j++) { game_map[i][j] = 0; } } if_game == 0; if_input = 0; load_desktop(); if_into_desktop = 1; put_in_num = 0; put_in_computer[0] = '\\0'; } else if (function == 3 &amp;&amp; if_into_desktop) { if (cy == 1) { load_game(); if_game = 1; } else { load_more(); getch(); load_desktop(); } } //if(if_game == 1 &amp;&amp; function &gt;= 5 &amp;&amp; function &lt;= 8)) 移动类型游戏暂未开放 if (if_into_desktop &amp;&amp; function &gt;= 5 &amp;&amp; function &lt;= 8) { int ncx = cx + next[function][0], ncy = cy + next[function][1]; if (computer_map[ncx][ncy]) { gotoxy(tcy, tcx); printf(&quot; &quot;); cx = ncx, cy = ncy; tcx = computer_map_place[computer_map[cx][cy]][0]; tcy = computer_map_place[computer_map[cx][cy]][1]; lcx = cx, lcy = cy; gotoxy(tcy, tcx); printf(&quot;[]&quot;); } } if (function == 1 &amp;&amp; if_into_desktop) { //返回 load_desktop(); } } int main() { init(); /*load_desktop();//直接进入桌面 if_start = 1; if_into_desktop = 1;*/ while (1) { //主循环 flag = move(); //move提取读取的键盘按键并判断类型 switch (flag) { case 0: break; //暂无效果的按键 case 1: put_letter_to_computer(letter); break; //返回字符型按键给电脑 case 2: put_function_to_computer(function); break; //返回功能型按键给电脑 } } getchar(); } ","link":"http://diego3893.github.io/post/cban-win-xp/"},{"title":"快速幂","content":"原理 在指数b大于0时： 若b为奇数，先将ans单独乘以底数a并mod m， 再将底数平方并mod m 若b为偶数，将底数平方并mod m b右移一位，即b/2 时间复杂度：O(lognlognlogn) 数学理解很简单，位运算参考这个 模版 #include&lt;cstdio&gt; using namespace std; typedef long long ll; ll qpower(ll, ll, ll); int main() { ll a, b, m; scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;m); printf(&quot;%lld&quot;, qpower(a, b, m)); } ll qpower(ll a, ll b, ll m) { ll ans = 1, res = a; while(b &gt; 0) { if(b &amp; 1) ans = ans*res%m; res = res*res%m; b &gt;&gt;= 1; } return ans; } ","link":"http://diego3893.github.io/post/kuai-su-mi/"},{"title":"二分查找","content":"原理 简单，不阐述 模版 ","link":"http://diego3893.github.io/post/er-fen-cha-zhao/"},{"title":"堆排序","content":"堆分为大根堆，小根堆 本文以大根堆为例 原理 一个数组存储整个序列 下标为k的数左孩子为2k+1, 右孩子为2k+2 保持每个子树的根值大于它孩子的值 对每一个非叶子节点进行排序 将整棵树的根节点（序列最大值）放到正在进行排序的末尾i 对0~i-1的序列继续排序 数组模拟的完全二叉树 模版 手动模拟 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; void adjust(int arr[], int len, int index) { int left = 2*index + 1; int right = 2*index + 2; int maxIdx = index; if(left&lt;len &amp;&amp; arr[left] &gt; arr[maxIdx]) maxIdx = left; if(right&lt;len &amp;&amp; arr[right] &gt; arr[maxIdx]) maxIdx = right; // maxIdx是3个数中最大数的下标 if(maxIdx != index) // 如果maxIdx的值有更新 { swap(arr[maxIdx], arr[index]); adjust(arr, len, maxIdx); // 递归调整其他不满足堆性质的部分 } } void heapSort(int arr[], int size) { for(int i=size/2 - 1; i &gt;= 0; i--) // 对每一个非叶结点进行堆调整(从最后一个非叶结点开始) { adjust(arr, size, i); } for(int i = size - 1; i &gt;= 1; i--) { swap(arr[0], arr[i]); // 将当前最大的放置到数组末尾 adjust(arr, i, 0); // 将未完成排序的部分继续进行堆排序 } } int main() { int array[8] = {8, 1, 14, 3, 21, 5, 7, 10}; heapSort(array, 8); for(int i=0; i&lt;8; ++i) cout&lt;&lt;array[i]&lt;&lt;' '; return 0; } STL #include&lt;cstdio&gt; #include&lt;queue&gt; using namespace std; int n,x,ans; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q; int main() { int n, x, ans = 0; scanf(&quot;%d&quot;, &amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;, &amp;x); q.push(x); } while(q.size()&gt;=2) { int a=q.top(); q.pop(); int b=q.top(); q.pop(); ans += a+b; q.push(a+b); } printf(&quot;%d&quot;, ans); return 0; } 代码题目传送门 注意 不使用#include&lt;vector&gt;头文件 greater是序列升序，less是序列降序 声明语句最后的两个 &gt; &gt; 要有一个空格 ","link":"http://diego3893.github.io/post/dui-pai-xu/"},{"title":"github + Gridea免费搭建静态博客","content":"0 Gridea的优缺点 优点： 使用简单 零成本 无需代码配置 界面美观 离线编辑，在线同步 缺点： 新软件没有详细说明 （所以需要看我的博客） 1 准备工作 安装git（可选）和Gridea 可以从官网安装： git Gridea 可以从百度网盘安装 网盘资源 提取码：ck6t 有git、gridea安装包和gridea主题 （仅限win） 2 安装软件 2.1 安装git（可选） 参考这个 2.2 安装Gridea 双击exe，选择全用户安装（第一个选项），然后一路下一步即可 3 搭建网站 3.0 加速github 参考这个 无法保存hosts解决办法 3.1注册github（有账号者略过） 进入github 具体步骤和其他注册方式无太大区别，此处不再赘述 3.2 创建仓库 点击New repository Repository name填写用户名.github.io e.g. 用户名为kkk， 则Repository name填写kkk.github.io Description可以不填 其余设置参照下图，然后点击Create repository 3.3 获取token 进入用户设置 进入开发者设置 选择最后一项，然后新建一个token Note随便填，只勾选repo权限 点击页面最下方的绿色按钮Generate token 你会得到一长串编码，把它保存下来，因为 以后你再也见不到它了 4 gridea设置博客 4.1 将博客同步至网页 在远程中设置如图 点击保存，点击检测远程连接 如果失败请检查设置信息是否正确 若一切正确但无法连接，参考这篇文章 然后点击左下角的同步 4.2 主题美化 将网盘资源中的gridea-themes解压，把里面的每个单文件夹（如song、jia、lin等）放入站点源文件夹中如下图 重启gridea后就可以选择主题了 我使用的是Chic 4.3 评论设置 4.3.1 新建一个仓库 设置默认，命名为blog-comment 4.3.2 新建Gitalk App 进入github账户的开发者设置 新建App，设置如下 保存两行代码 4.3.3 连接至博客 设置如下： 每篇文章都需要初始化评论，新文章评论区github登陆 5 编辑博文 使用markdown编辑，语法参考 这个应用不会自动同步，需要点击同步按钮 如果想配置自己的域名，可以移步至我的这篇博客 感谢阅读本蒟蒻的博客，如有问题请在下方评论 欢迎参观我的博客 ","link":"http://diego3893.github.io/post/github-gridea-mian-fei-da-jian-jing-tai-bo-ke/"},{"title":"最小生成树","content":"Kruskal 原理 以边来求 排序实现 依次检查边是否处于联通块中 并查集 实现 以保证图连通且路径总权值最小 时间复杂度: O(M log M) 优化 if(k == n-1) break; 其中k为已选边数，n为点数，因为为连通的树, 所以边数=点数-1 模版 #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; void merge(int, int); int getf(int); void add_edge(int, int, int); int f[1002] = {}, edge_num = 0, n, m; struct node{ int u, v, w; }edge[100002]; bool cmp(const node&amp;, const node&amp;); int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int a, b, c; for(int i=1; i&lt;=m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); add_edge(a, b, c); } sort(edge+1, edge+edge_num+1, cmp); int ans = -0x7ffffff, k = 0; int flag = 0; for(int i=1; i&lt;=m; ++i) { int t1 = getf(edge[i].u), t2 = getf(edge[i].v); if(t1 != t2) { merge(t1, t2); if(ans &lt; edge[i].w) ans = edge[i].w; ++k; } if(k == n-1) { flag = 1; break; } } if(!flag) printf(&quot;-1&quot;); else printf(&quot;%d&quot;, ans); return 0; } bool cmp(const node &amp;a, const node &amp;b) { return a.w &lt; b.w; } void add_edge(int a, int b, int c) { edge[++edge_num].u = a; edge[edge_num].v = b; edge[edge_num].w = c; return; } void merge(int x, int y) { int t1 = getf(x), t2 = getf(y); if(t1 != t2) f[t2] = t1; return; } int getf(int x) { if(f[x]!=x &amp;&amp; f[x]!=0) return f[x] = getf(f[x]); return x; } 代码题目 传送门 Prim 原理 类似Dijkstra的松弛， 依次将白点变为蓝点 需要一个数组打标记，用k记录最小出边（初始化k = -1) 每次将dis数组更新为当前节点的所有出边的权值 找拥有最小权值的出边k 打标记book[k] = 1; 以k节点重复第一步 求和dis数组，即为最短路径和 时间复杂度：O(N2N^2N2) 模版 #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int g[102][102]; int minn[102]; int book[102] = {}; int main() { int n; scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=n; ++j) scanf(&quot;%d&quot;, &amp;g[i][j]); memset(minn, 0x7f, sizeof(minn)); minn[1] = 0; memset(book, 0, sizeof(book)); for(int i=1; i&lt;=n; ++i) { int k = 0; for(int j=1; j&lt;=n; ++j) if(!book[j] &amp;&amp; (minn[j]&lt;minn[k])) k = j; book[k] = 1; for(int j=1; j&lt;=n; ++j) if(!book[j] &amp;&amp; (g[k][j]&lt;minn[j])) minn[j] = g[k][j]; } int ans = 0; for(int i=1; i&lt;=n; ++i) ans += minn[i]; printf(&quot;%d&quot;, ans); return 0; } 代码题目传送门 选择 Prim适合稠密图，Kruskal适合稀疏图 本蒟蒻小声BB：最小生成树其实不难 欢迎来我的博客 ","link":"http://diego3893.github.io/post/zui-xiao-sheng-cheng-shu/"},{"title":"并查集","content":"技巧 可以不用一下代码初始化与找根 for(int i=1; i&lt;=n; ++i) f[i] = i; int getf(int x) { if(f[x] == x) return x; return f[x] = getf(f[x]); } 简化后 int getf(int x) { if(f[x]!=0 &amp;&amp; f[x]!=x) return f[x] = getf(f[x]); return x; } 原理 以递归压缩路径———getf 合并路径——将节点编号变为根节点编号 根相同，则在同一个子集 模版 并查集 #include &lt;cstdio&gt; using namespace std; int getf(int); void merge(int, int); inline int fread(); int n, m, f[20002] = {}, q; int main() { n = fread(); m = fread(); int a, b; for(int i=1; i&lt;=m; ++i) { a = fread(); b = fread(); merge(a, b); } q = fread(); for(int i=1; i&lt;=q; ++i) { a = fread(); b = fread(); int t1 = getf(a), t2 = getf(b); if(t1 == t2) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); } return 0; } int getf(int x) { if(f[x]!=x &amp;&amp; f[x]!=0) return f[x] = getf(f[x]); return x; } void merge(int v, int u) { int t1, t2; t1 = getf(v); t2 = getf(u); if(t1 != t2) f[t2] = t1; return; } inline int fread() { int x=0,f=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){ if(ch=='-') f=-1; ch=getchar(); } while(ch&gt;='0'&amp;&amp;ch&lt;='9'){ x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); } return x*f; } ","link":"http://diego3893.github.io/post/bing-cha-ji/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"http://diego3893.github.io/post/hello-gridea/"}]}